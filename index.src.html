<pre class='metadata'>
Title: Origin Policy
Status: DREAM
ED: https://mikewest.github.io/origin-policy/
Shortname: origin-policy
Level: None
Editor: Mike West 56384, Google Inc., mkwst@google.com
Abstract:
  This specification defines a delivery mechanism for a number of policies
  which are to be applied to an entire origin. It compliments header-based
  delivery mechanisms for existing policies (Content Security Policy,
  Referrer Policy, etc).
Indent: 2
Markup Shorthands: markdown on
Boilerplate: omit conformance, omit feedback-header
!Participate: <a href="https://discourse.wicg.io/t/proposal-set-origin-wide-policies-via-a-manifest/1617">Discuss in the WICG</a>. <a href="https://github.com/mikewest/origin-policy/issues/new">File an issue</a> (<a href="https://github.com/mikewest/origin-policy/issues">open issues</a>)
</pre>
<pre boilerplate="copyright">&copy;2016 Google, Inc.</pre>
<pre class="link-defaults">
spec:html; type:element; text:link
</pre>
<pre class="anchors">
spec: CSP3; urlPrefix: https://w3c.github.io/webappsec-csp/
  type: dfn
    text: Content Security Policy
spec: HTML; urlPrefix: https://html.spec.whatwg.org/
  type: dfn
    text: origin; url: concept-origin
    text: opaque origin; url: concept-opaque-origin
spec: REFERRER-POLICY; urlPrefix: https://w3c.github.io/webappsec-referrer-policy/
  type: dfn
    text: referrer-policy; url: referrer-policy-header
spec: RFC7540; urlPrefix: https://tools.ietf.org/html/rfc7540
  type: dfn
    text: server push; url: section-8.2
spec: RFC6797; urlPrefix: https://tools.ietf.org/html/rfc6797
  type: dfn
    text: Strict-Transport-Security; url: section-8.1
<!--
   -   WHATWG
   -->
spec: FETCH; urlPrefix: https://fetch.spec.whatwg.org/
  type: dfn
    text: CORS-preflight request
    text: ok status
    text: network error; url: concept-network-error
    text: header list; url: concept-header-list
    for: header list
      text: extract a MIME type; url: concept-header-extract-mime-type
    text: parsing; for: header list; url: concept-header-parse
    for: body
      text: wait; url: concept-body-wait
    for: request
      text: url; url: concept-request-url
      text: destination; url: concept-request-destination
      text: mode; url: concept-request-mode
      text: client; url: concept-request-client
      text: skip-service-worker flag
      text: redirect mode; url: concept-redirect-mode
    for: response
      text: header list; url: concept-response-header-list
      text: CSP list; url: concept-response-csp-list
      text: URL; url: concept-response-url
      text: status; url: concept-response-status
      text: body; url: concept-response-body
    text: X-Content-Type-Options; url: x-content-type-options-header
spec: URL; urlPrefix: https://url.spec.whatwg.org/
  type: dfn
    text: origin; for: url; url: concept-url-origin
    text: path; for: url; url: concept-url-path
    text: URL parser; url: concept-url-parser
<!--
   -   ABNF
   -->
type: grammar
  text: base64-value; url: https://w3c.github.io/webappsec-csp/#grammardef-base64-value; spec: CSP3
  text: DQUOTE; url: https://tools.ietf.org/html/rfc5234#appendix-B.1; spec: RFC5234
</pre>
<pre class="biblio">
{
  "SITE-WIDE-HEADERS": {
      "href": "https://mnot.github.io/I-D/site-wide-headers/",
      "title": "Site-Wide HTTP Headers",
      "authors": [ "Mark Nottingham" ]
  }
}
</pre>

Introduction {#intro}
=====================

Developers set a number of properties associated with resources on an origin
by delivering resource-specific HTTP response headers and <{meta}> elements.
This is becoming more common over time, and it's quite normal these days to see
multiple kilobytes at the beginning of every response dedicated to such
metadata. Setting this metadata is valuable indeed, as it can have a large
impact on performance, security, and privacy.

However, the existing delivery mechanism is ill-suited to the task, suffering
from a clear mismatch between the resource-specific nature of the metadata
declarations on the one hand, and the origin-wide intent of the metadata on the
other. Take `Strict-Transport-Security` [[RFC6797]] and `Public-Key-Pins`
[[RFC7469]], for example, which explicitly alter the state of an entire origin,
but are delivered in resource-specific response headers.

Moreover, many resource-specific headers are deployed in such a way as to be
<i lang="la">de facto</i> static across all resources that an origin serves.
`Content-Security-Policy` [[CSP3]], for instance, can be very granular indeed,
but is commonly implemented by setting a single policy which is delivered for
an entire application.

A number of implications follow:

1.  Servers are required to repeat themselves. At length.
    `Content-Security-Policy` alone can easily eat multiple kilobytes of each
    navigational response, bandwidth which could instead be dedicated to content
    a user might care about. This has obvious and direct impact on the delay a
    user experiences when navigating, but has less obvious knock-on effects that
    reduce performance further. HTTP/2's HPACK [[RFC7541]] header compression
    is limited to ~4k of state for processing, for instance, meaning that these
    verbose headers can greatly reduce its effectiveness

2.  Servers are required to repeat themselves. Unerringly. When policy applies
    strictly to a resource, and not to the origin, then a server must send that
    policy down with every response. If the developer forgets a page (which is
    actually a very common occurence: when's the last time you thought about
    your 404 error page? How about your 417? Or 505?), then the policy's
    protections don't apply to that resource, leaving an exploitable hole.

This document introduces a new delivery mechanism for policies which are meant
to apply to an entire origin. In short, a server will provide an <a>Origin
Policy Manifest</a> file at a well-known location. This file contains all of the
metadata the server would like to set for each response. User agents can be
instructed to synchronously download and process this manifest before completing
a navigation to an origin's resources, ensuring that the policy contained therin
will be safely applied to each resource, and allowing the server to skip the
overhead of including the relevant headers with each response. Typically, the
server can speed things up even more by using HTTP/2 Server Push ([[RFC7540]],
section 8.2) to proactively send the manifest file along with the response to
the user agent's first request.

Examples {#examples}
--------------------

<div class="example">
MegaCorp, Inc. wishes to ensure that a baseline content security policy is
applied to each of the pages on `https://example.com`, while avoiding the
overhead associated with large response headers, and the uncertainty that
they've really covered everything that lives on the origin.

When they see a request come in that contains a <a>`Origin-Policy`</a>
header, they can respond in kind, pointing the client to a manifest file
in a well-known location on their server. That is, given the following
request:

<pre>
GET / HTTP/1.1
Host: example.com
Connection: keep-alive
...
<a>Origin-Policy</a>: 0
...
</pre>

MegaCorp, Inc. can respond with:

<pre>
HTTP/1.1 200 OK
Content-Encoding: gzip
Accept-Ranges: bytes
Cache-Control: max-age=604800
Content-Type: text/html
...
<a>Origin-Policy</a>: "policy-1"
...
</pre>

The client will parse the response headers, and synchronously request
`https://example.com/.well-known/origin-policy/v1` before completing
the navigation. The policies contained in that file will be cached
according to the normal HTTP caching rules, and applied to pages on
`https://example.com/` (including the current navigation).

<pre>
{
  "<a>headers</a>": {
    "<a>fallback</a>": [
      {
        "name": "<a>Content-Security-Policy</a>",
        "value": "<a>script-src</a> 'self' https://cdn.example.com"
      },
      {
        "name": "<a>Referrer-Policy</a>",
        "value": "origin-when-cross-origin"
      }
    ],
    "<a>baseline</a>": [
      {
        "name": "<a>Content-Security-Policy</a>",
        "value": "<a>object-src</a> 'none'; <a>frame-ancestors</a> 'none'"
      },
      {
        "name": "<a>Strict-Transport-Security</a>",
        "value": "max-age=10886400; includeSubDomains; preload"
      },
      {
        "name": "<a>X-Content-Type-Options</a>",
        "value": "nosniff"
      }
    ]
  },
  "<a>cors-preflight</a>": { /* TODO(mkwst): Syntax? */ },
}
</pre>

Subsequent requests from the same client will contain the version of
the policy currently cached for the origin. In this case:

<pre>
GET / HTTP/1.1
Host: example.com
Connection: keep-alive
...
<a>Origin-Policy</a>: "<strong>policy-1</strong>"
...
</pre>

Note: MegaCorp, Inc. can signficantly speed up this interaction by proactively
pushing the current manifest down to the client along with the initial response.
See [[#server-push]] for details.
</div>

<div class="example">
MegaCorp, Inc. wishes to update the origin policy it has distributed to clients.
It can do so by setting an appropriate `Origin-Policy` header in the response.
That is, given the following request:

<pre>
GET / HTTP/1.1
Host: example.com
Connection: keep-alive
...
<a>Origin-Policy</a>: "<strong>policy-1</strong>"
...
</pre>

MegaCorp, Inc. can respond with:

<pre>
HTTP/1.1 200 OK
Content-Encoding: gzip
Accept-Ranges: bytes
Cache-Control: max-age=604800
Content-Type: text/html
...
<a>Origin-Policy</a>: "policy-2"
...
</pre>

The client will process the header, download and process the `policy-2` manifest,
and apply it to the response.
</div>

<div class="example">
MegaCorp, Inc. wishes to remove the origin policy it has distributed to clients.
It can do so by setting an `Origin-Policy` header with a value of `0` in the
response:

<pre>
HTTP/1.1 200 OK
Content-Encoding: gzip
Accept-Ranges: bytes
Cache-Control: max-age=604800
Content-Type: text/html
...
<a>Origin-Policy</a>: 0
...
</pre>

The client will process the header, and evict any origin policy for the
response's origin.

Note: The manifest itself will be removed, but some of the policies it set may
still be effective. For example, if the <a>Strict-Transport-Security</a> header
was set, the `maxage` property it contained may still force TLS on any connection
to the origin's host. Those kinds of behaviors will need to be cleared
individually, as appropriate for the feature. For example, to remove HSTS, the
server could send `Strict-Transport-Security: maxage=0`.
</div>

Framework {#framework}
======================

Concepts {#concepts}
--------

An <dfn>origin policy object</dfn> is a tuple of a string
(<dfn for="origin policy object">version</dfn>), and the contents of an
<a>origin policy manifest</a> (<dfn for="origin policy object">body</dfn>).

User agents have a <dfn export>Origin Policy Store</dfn>, which is a key/value
store that constitutes a 1:1 mapping between <a>origin policy objects</a> and
<a for="">origins</a>.

When asked to <dfn algorithm local-lt="get-policy-from-store">retrieve an Origin
Policy for an origin</dfn>, an <a>Origin Policy Store</a> will return either a
single <a>origin policy object</a> (if one is stored for the given origin), or
`null` (if nothing is stored for the given origin).

When asked to <dfn algorithm local-lt="evict-policy-from-store">evict an Origin
policy for an origin</dfn>, an <a>Origin Policy Store</a> will discard any
<a>origin policy object</a> associated with the given origin.

The `Origin-Policy` HTTP Header Field {#origin-policy-header}
-----------------------------------------------------------------

The <dfn export>`Origin-Policy`</dfn> HTTP header field is sent with
navigational HTTP requests in order to advertise support generally for the
origin policy manifest mechanism defined in this document, and to inform
the server which version of its origin policy is cached locally.

The same header is sent by the server in responses to such requests to
inform the client that a origin policy manifest is available to fetch. Its
value MUST be either `0` or a base64-encoded value, wrapped in double-quotes.
The following ABNF defines that more formally:

<pre class="abnf" dfn-type="grammar" link-type="grammar">
  Origin-Policy: 0 / <a>manifest-name</a>
  <dfn>manifest-name</dfn>: <a>DQUOTE</a> <a>base64-value</a> <a>DQUOTE</a>
  ; base64-value is defined in [[!CSP3]]
  ; DQUOTE is defined in [[!RFC5234]]
</pre>

This header MUST be ignored if [[secure-contexts#is-url-trustworthy]] returns
"`Not Trustworthy`" when executed upon the response's URL.

The Origin Policy Manifest File {#manifest-file}
------------------------------------------------------

The <dfn export local-lt="manifest">Origin Policy Manifest</dfn> is a
JSON-formatted document consisting of a top-level object with one or more
members. Each member defines a specific aspect of an origin's policy.

<pre class="example">
{
  "<a>headers</a>": {
    "fallback": [
      {
        "name": "<a>Content-Security-Policy</a>",
        "value": "<a>script-src</a> 'self' https://cdn.example.com"
      },
      {
        "name": "<a>Referrer-Policy</a>",
        "value": "origin-when-cross-origin"
      }
    ],
    "baseline": [
      {
        "name": "<a>Content-Security-Policy</a>",
        "value": "<a>object-src</a> 'none'; <a>frame-ancestors</a> 'none'"
      },
      {
        "name": "<a>Strict-Transport-Security</a>",
        "value": "max-age=10886400; includeSubDomains; preload"
      },
      {
        "name": "<a>X-Content-Type-Options</a>",
        "value": "nosniff"
      }
    ]
  },
  "<a>cors-preflight</a>": { /* TODO(mkwst): Syntax? */ },
}
</pre>

### The `origin-policy` well-known location ### {#origin-policy-well-known}

<a>Origin Policy Manifest</a> files for a given origin MUST be located as
suffixes to the well-known location `/.well-known/origin-policy` [[RFC5785]].
Their names MUST be double-quoted strings of characters matching the
<a grammar>base64-value</a> grammar. That is, `/.well-known/origin-policy/a`
might point to one <a>Origin Policy Manifest</a> file, while
`/.well-known/origin-policy/b` might point to another.

Servers MUST respond to a `GET` request to `/.well-known/origin-policy` with a
302 redirect whose `Location` header points to the origin's current <a>Origin
Policy Manifest</a>, or with a 404 response if no such policy is available.

Note: This redirect can be used as a discovery mechanism. User agents might
prefetch such manifest files for origins a user is likely to visit, testing
services might give developers automated feedback on their origin's manifest,
etc.

### The `headers` member ### {#headers-member}

The <dfn export>`headers`</dfn> member defines a set of HTTP response headers
which will be automatically appended to resources delivered from the manifest's
origin. The headers specified in this member's value are categorized either as
<dfn>baseline headers</dfn> which appended to <em>every</em> resource served by
the origin, or as <dfn>fallback headers</dfn> which are appended only to those
resources which don't themselves deliver the header.

The <a>`headers`</a> member's value MUST be a dictionary which contains either
a <dfn export>`baseline`</dfn> member, a <dfn export>`fallback`</dfn> member, or
both. Any additional members will be ignored.

The <a>`headers`</a> member will be ignored entirely if it contains neither a
<a>`baseline`</a> member nor a <a>`fallback`</a> member.

Both the <a>`baseline`</a> and <a>`fallback`</a> members' values MUST be lists
of dictionaries containing both `name` and `value` members. Members other than
`name` and `value` will be ignored. List items that do not have both `name`
and `value` members will be ignored.

ISSUE: It may be a dangerous (or at least confusing) footgun to allow certain
headers to be set on an origin (consider `Content-Type` or `Content-Length`,
for instance). Perhaps it would be reasonable to limit the <a>`headers`</a>
member to some whitelist of expected headers?

### The `cors-preflight` member ### {#cors-preflight-member}

The <dfn export>`cors-preflight`</dfn> member asserts that an origin understands
the CORS protocol, and that the user agent can therefore assume success for
certain types of <a>CORS-preflight requests</a>.

Note: This member does <em>not</em> set defaults for responses in general; it
only allows the user agent to skip the `OPTIONS` preflight request for a
defined set of requests.

Its value MUST be a dictionary. Any other type will be ignored.

#### Values #### {#cors-preflight-values}

ISSUE(mikewest/origin-policy#3): Spell this out in some sane way. Maybe
like the following?

<pre class="example">
  {
    "cors-preflight": {
      "allow-credentials": true,
      "allow-headers": [ "x-application-specific-header" ],
      "allow-origin": [ "https://not-example.com/" ]
    }
  }
</pre>

Algorithms {#algorithms}
==========

<h3 algorithm dfn id="version-for-origin">
  Retrieve |origin|'s manifest version.
</h3>

Given an origin (|origin|), this algorithm returns `0` if no manifest is present
in the user agent's <a>Origin Policy Store</a>, or a string representing the
cached version otherwise.

1.  Let |version| be `0`.

2.  If the user agent's <a>Origin Policy Store</a> contains a tuple for
    |origin|, let |version| be that tuple's first element.

3.  Return |version|.

<h3 algorithm dfn id="evict-for-origin">
  Evict |origin|'s cached manifest.
</h3>

Given an origin (|origin|), this algorithm removes any cached manifest from the
user agent's <a>Origin Policy Store</a>:

1.  Instruct the user agent's <a>Origin Policy Store</a> to
    <a lt="evict-policy-from-store">evict</a> any <a>Origin Policy object</a>
    stored for |origin|.

HTML Integration {#monkey-patching-html}
----------------

At the end of the navigation algorithm, we'll do the following:

1.  If we have a policy for the origin to which we've navigated (or we're inheriting the
    origin for an `about:blank` or `about:srcdoc` (or if we're Firefox, `data:...`),
    then we apply the policy to the document as defined in [[#html-apply-policy]] (which
    I haven't written yet.

At the end of the "run a worker" algorithm, we'll do the same thing.

<h4 algorithm dfn id="html-apply-policy">
  Apply Origin Policy to |settings|.
</h4>

ISSUE: Write this algorithm.

Fetch Integration {#monkey-patching-fetch}
-----------------

During a navigation request, Fetch will hook into this specification in two ways:

1.  At the top of the basic fetch algorithm, Fetch will call
    [[#fetch-prepare-request]] in order to append `Origin-Policy` to the
    request's header list with a value of `0` if no manifest is cached for its
    URL's origin, or a value of the verion of the manifest that is cached  (e.g.
    `"v1"`).

2.  When a response is received during HTTP-network fetch algorithm, Fetch will
    call into [[#fetch-parse-response]] to sift through its headers, and
    extract the `Origin-Policy` header. If present, and its value does not match
    the value of the locally cached manifest for the response's origin, we'll issue
    a synchronous request for a resource located on the request's URL's origin at
    `/.well-known/origin-policy/{value}`, as defined in [[#fetch-parse-response]].

    The manifest request will fail in a draconian fashion: if
    [[#fetch-parse-response]] returns "`Failure`", the response to the request
    which triggered the manifest request will be set to a <a>network error</a>.

    ISSUE: Should we allow service workers to intercept/set policy? Maybe only if they
    are scoped to the whole origin?

3.  Directly after Fetch calls into [[#fetch-parse-response]], it will call into
    [[#fetch-apply-policy]] to apply any cached policy to the response.

<h4 algorithm dfn id="fetch-prepare-request">
  Prepare |request| with Origin Policy.
</h4>

Given a request |request|, add appropriate headers to inform a server about a
client's active policy:

1.  If |request| is not a navigation request, or if
    [[secure-contexts#is-url-trustworthy]] returns "`Not Trustworthy`" when
    executed upon |request|'s <a for="request">url</a>, then abort these steps.

2.  Let |version| be the result of executing [[#version-for-origin]] on
    |request|'s URL's origin.

3.  Append a header named `Origin-Policy` with a value of |version| to
    |request|'s header list.

<h4 algorithm dfn id="fetch-parse-response">
  Process |response| for Origin Policy.
</h4>

Given a response (|response|), this algorithm will sift through its headers, and
fetch or evict the relevant <a>Origin Policy Manifest</a> as follows:

*  If no "`Origin-Policy`" header is present, this algorithm returns "`No-op`".

*  If an "`Origin-Policy`" header is present with a value of `0`, this
   algorithm will evict the relevant manifest, and return "`Success`".

*  If an "`Origin-Policy`" header is present with a non-`0` value, this
   algorithm will attempt to fetch the specified manifest. If successful,
   the manifest will be cached locally, and this algorithm will return
   "`Success`". If the fetch fails, this algorithm will return "`Failure`".

1.  Let |version| be the result of parsing "`Origin-Policy`" in |response|'s
    header list.

2.  Let |url| be a copy of |response|'s <a for="response">URL</a>.

3.  Return "`No-op`" if any of the following statements are true:

    1.  |version| is `null`.

    2.  [[secure-contexts#is-url-trustworthy]] returns "`Not Trustworthy`" when
        executed upon |url|.

4.  Assert: |url| is not an <a>opaque origin</a>.    

5.  Return "`Failure`" if |version| does not match the
    <a grammar>manifest-name</a> grammar.

6.  If |version| is `0`:

    1.  Execute [[#evict-for-origin]] upon |url|'s <a for="url">origin</a>.
    
    2.  Return "`Success`".

7.  Replace |url|'s <a for="url">path</a> with the concatenation of
    "`/.well-known/origin-policy/`" and |version|.

8.  Let |request| be a new request with the following properties:

    :   <a for="request">url</a>
    ::  |url|
    :   <a for="request">client</a>
    ::  `null`
    :   <a for="request">skip-service-worker flag</a>
    ::  Set
    :   <a for="request">destination</a>
    ::  "`manifest`"
    :   <a for="request">mode</a>
    ::  "`same-origin`"
    :   <a for="request">redirect mode</a>
    ::  "`error`"

9.  Let |response| be the result of performing an HTTP-network-or-cache fetch
    using |request|.

10. If |response|'s <a for="response">status</a> is an <a>ok status</a>:

    1.  Let |MIME type| be the result of
        <a for="header list" lt="extract a MIME type">extracting a MIME type</a>
        from |response|'s <a for="response">header list</a>.

    2.  If |MIME type| is not `application/manifest+json`, abort these steps
        and return "`Failure`".

    3.  <a for="body">Wait</a> for |response|'s <a for="response">body</a>.

    4.  Store the tuple (|version|, |response|'s <a for="response">body</a>) in
        the user agent's <a>Origin Policy Store</a> for |response|'s
        <a for="response">URL</a>'s <a for="url">origin</a>.

    5.  Return "`Success`".

11. Return "`Failure`"

<h4 algorithm dfn id="fetch-apply-policy">
  Apply an Origin Policy to |response|.
</h4>

Given a response (|response|), the following algorithm applies the relevant
<a>origin policy object</a>:

1.  Let |origin| be |response|'s URL's origin.

2.  If |origin| is an opaque origin, or if
    [[secure-contexts#is-origin-trustworthy]] returns "`Not Trustworthy`" when
    executed upon |origin|, abort these steps and return.

3.  Let |object| be the result of instructing the user agent's <a>Origin Policy
    Store</a> to <a lt="get-policy-from-store">retrieve an Origin Policy
    object</a> for |origin|.

4.  If |object| is `null`, abort these steps and return.

5.  Set |policy| to |object|'s <a for="origin policy object">body</a>.

6.  For each member (|member|) in |policy|, execute the steps associated with
    the matching statement below:

    :   <a>`headers`</a>
    ::  1.  If |member|'s value is not valid as defined in [[#headers-member]],
            abort these steps and return.

            ISSUE: Is there a better way to define validity? JSON schema?

        2.  Let |headers| be an empty list.

        3.  If |member|'s value has a <a>`fallback`</a> member (|fallback|),
            then for each |header| in |fallback|'s value:

            1.  If the result of <a for="header list">parsing</a> |header| in
                |response|'s <a for="response">header list</a> is not `null`,
                skip the remaining substep, and proceed to the next |header|.

                Note: We check the header's presence before applying <a>baseline
                headers</a> to |response|.

            2.  Append |header|'s value to |headers|.

        4.  If |member|'s value has a <a>`baseline`</a> member (|baseline|),
            then append each |header| in |baseline|'s value, to |headers|.

        5.  For each |header| in |headers|:

            1.  Let |name| be |header|'s `name` member's value, and |value|
                be |header|'s `value` mamber's value.

            2.  Append a header named |name| with a value of |value| to
                |response|'s <a for="response">header list</a>.

        Note: Once a policy is cached for an origin, the headers it applies
        will never change. User agents are encouraged to implement more
        performant algorithms making use of this invariant.


Specification Considerations {#specification}
=============================

Relation to Web App Manifests {#app-manifest}
-----------------------------

It might make sense to combine this mechanism with the manifest notion
defined in [[APPMANIFEST]]. There are a few distinctions, however, which
lead to the current design:

1.  The =Security Policy Manifest= is delivered synchronously during navigation,
    which gives it a number of valuable security properties. The web app
    manifest, on the other hand, is delivered inline via a <{link}> element,
    which makes it less valuable from that perspective.

2.  Web app manifests can live anywhere on an origin, and anywhere on any other
    origin, for that matter. This might make sense for the feature set it wishes
    to expose, but it would expose an origin to unnecessary risk to be quite so
    loose with =security policy manifest= files.

Nevertheless, we should consider ways to merge this policy with [[APPMANIFEST]].
Perhaps we could accept a certain set of attributes was parsed iff certain
properties of the request are true (same-origin, specific path, etc). Something
to look into. For now, we've done the simple thing as a strawman.

Why `.well-known`? {#why-well-known}
------------------

This document forces the manifest to live as a resource accessible under a
"well-known location" specific to Origin Policy manifests. It would increase
flexibility of deployment and implementation if we allowed a developer to point
to any location on an origin instead. Perhaps something like the following:

```
  Origin-Policy: /path/to/manifest.json
```

This would allow developers who control an application, but not the server on
which the application runs, to define policy for themselves without bothering
the sysadmins and filing internal tickets to get a `.well-known` directory
created, populated, and mapped to something externally accessible.

So why does this document force a well-known location?

In short, this document posits that setting a policy for an origin is an action
that should, in fact, involve the folks responsible for running the origin's
server, as it has cross-cutting effects upon <em>every</em> application hosted
on an origin. Unlike a response-specific `Content-Security-Policy` header, the
<a>`headers`</a> member can apply a baseline policy to <em>all</em> the responses
an origin emits. This can be hugely benificial, but also hugely destructive.

Consider, for example, MegaCorp, Inc.'s `https://example.com`, which
hosts a mail application, a mapping application, a document editing application,
and so on. It would be unfortunate indeed if one of these applications
accidentally pinned a policy to the entire origin which didn't account for the
rest of the origin's contents. To mitigate that risk, this document forces the
manifest to live in a shared location for an origin. The goal is explicitly to
eilicit the kind of discussion and compromise within an origin that needs to
happen in order to deploy an Origin Policy safely.

Authoring Considerations {#authoring}
========================

Headers To Set {#headers-to-set}
--------------

Authors SHOULD explicitly set a number of headers to construct a reasonable
policy for their sites. Among the most important are:

*   `Content-Security-Policy` [[CSP3]]
*   `Strict-Transport-Security` [[RFC6797]]
*   `X-Content-Type-Options` [[FETCH]]

ISSUE: Give some reasonable recommendations here, with links to tutorials if possible.

Performance {#perf}
-----------

Servers SHOULD set a long cache lifetime for the manifest file, using the version
to change policy for an origin as opposed to changing the existing policy and
relying on cache expiration.

Server Push {#server-push}
-----------

To speed up the initial, synchronous request for the manifest file, servers
SHOULD use the <a>Server Push</a> mechanism defined in [[RFC7540]] to get the
manifest down to the client as quickly as possible.

1.  Send a `PUSH_PROMISE` frame with a minimal request for the manifest,
    aligning with the request generated in [[#fetch-parse-response]].

2.  Begin delivering the response to the `PUSH_PROMISE` request.

ISSUE: Spell this out with an example.

CSP: Nonces and `'strict-dynamic'` {#strict-dynamic}
----------------------------------

Content Security Policy has introduced some dynamic mechanisms that are quite
valuable in terms of encouraging deployment. Nonces, along with the
<a grammar>`'strict-dynamic'`</a> expression are a good example of an
implementation which requires a server to send a fresh value down with each
response. Origin Policy can support such deployments via the "`fallback`"
mechanism as follows:

<div class="example">
MegaCorp, Inc. wishes to deploy a strong Content Security Policy which blocks
plugins and framing altogether, but which uses `'strict-dynamic'` along with a
fresh nonce for each resource in order to reduce the risk of cross-site
scripting. It can do so by combining a "`baseline`" and "`fallback`" policy in
the <a>Origin Policy Manifest</a>, and delivering a `Content-Security-Policy`
header along with each response.

That is, the manifest file might contain the following JSON:

<pre>
{
  ...
  "<a>headers</a>": {
    "<a>fallback</a>": [
      {
        "name": "Content-Security-Policy",
        "value": "script-src 'none'"
      }
    ],
    "<a>baseline</a>": [
      {
        "name": "Content-Security-Policy",
        "value": "object-src 'none'; frame-ancestors 'self'"
      }
    ]
  },
  ...
}
</pre>

And each resource's response might contain the following header:

<pre>
  <a>Content-Security-Policy</a>: script-src 'nonce-{nonce-goes-here}' 'strict-dynamic'
</pre>

The baseline policy will be applied to every response, blocking plugins and
restricting framing regardless of the response's other headers.

The fallback policy will be applied iff the response doesn't itself provide a
Content Security Policy, meaning that the resource's policy will be applied,
the nonce will be active, and script will execute as expected.
</div>

Privacy and Security Considerations {#privacy-and-security}
===================================

Tracking {#tracking}
--------

The <a>`Origin-Policy`</a> header, as well as the manifest it represents, can
be used to track users with only marginally less granularity and coverage than
cookies allow. As such, the user agent MUST purge an origin's cached manifests
whenever a user instructs it to clear cookies or cached data for that origin.

IANA Considerations {#iana}
===================

The `Origin-Policy` header {#iana-header}
--------------------------

The permanent message header field registry should be updated
with the following registration: [[!RFC3864]]

:   Header field name
::  `Origin-Policy`
:   Applicable protocol
::  http
:   Status
::  WIP
:   Author/Change controller
::  W3C
:   Specification document
::  This specification (see [[#origin-policy-header]])

Creation of the well-known location `origin-policy` {#iana-well-known}
---------------------------------------------------

This document defines a well-known location at which <a>Origin Policy
manifests</a> may be found. In accordance with [[RFC5758]], the following
registration should be made if and when the proposal in this document gains
acceptance and implementation:

:   URI Suffix
::  `origin-policy`
:   Change Controller
::  W3C
:   Specification document
::  This document (see [[#origin-policy-well-known]])
:   Related information
::  The suffix `origin-policy` is expected to be followed by an additional path
    component which names a specific <a>Origin Policy manifest</a> (e.g.
    `/.well-known/origin-policy/name`). A request to
    `/.well-known/origin-policy` can be expected to redirect to the most current
    policy for an origin.

Acknowledgements {#ack}
================

Mark Nottingham came up with more or less the same idea at more or less the
same time (after waiting ~years for me to write this up) [[SITE-WIDE-HEADERS]].
I've swiped large swaths of his introduction, and turned a mess of a syntax into
<a>`headers`</a>, as it's better than what I was coming up with.
