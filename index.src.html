<pre class="metadata">
Title: Origin Policy
Status: CG-DRAFT
Group: WICG
Repository: WICG/origin-policy
Shortname: origin-policy
Level: None
URL: https://wicg.github.io/origin-policy/
Editor: Domenic Denicola, Google https://www.google.com/, d@domenic.me, https://domenic.me/
Former Editor: Mike West 56384, Google https://www.google.com/, mkwst@google.com
Abstract:
  This specification defines a delivery mechanism for a number of policies
  which are to be applied to an entire origin. It complements header-based
  delivery mechanisms for existing policies (Content Security Policy,
  Referrer Policy, etc).
Indent: 2
Default Biblio Status: current
Boilerplate: omit conformance, omit feedback-header
Complain About: accidental-2119 yes, missing-example-ids yes
Markup Shorthands: css no
!Participate: <a href="https://github.com/WICG/origin-policy">GitHub WICG/origin-policy</a> (<a href="https://github.com/WICG/origin-policy/issues/new">new issue</a>, <a href="https://github.com/WICG/origin-policy/issues?state=open">open issues</a>)
</pre>

<pre class="biblio">
{
  "STRUCTURED-HEADERS": {
    "authors": ["Mark Nottingham", "Poul-Henning Kamp"],
    "href": "https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html",
    "title": "Structured Headers for HTTP",
    "status": "ID",
    "publisher": "IETF"
  },
  "SITE-WIDE-HEADERS": {
      "href": "https://mnot.github.io/I-D/site-wide-headers/",
      "title": "Site-Wide HTTP Headers",
      "authors": ["Mark Nottingham"]
  },
  "ORIGIN-WIDE-CORS": {
      "href": "https://github.com/tyoshino/origin-wide-cors/blob/master/README.md",
      "title": "Origin-Wide CORS",
      "authors": ["Takeshi Yoshino"]
  }
}
</pre>

<pre class="link-defaults">
spec:infra; type:dfn; text:list
spec:infra; type:dfn; for:/; text:string
spec:infra; type:dfn; for:list; text:for each
spec:fetch; type:dfn; for:/; text:request
spec:fetch; type:dfn; for:/; text:fetch
spec:fetch; type:dfn; for:/; text:response
spec:csp; type:dfn; for:/; text:csp list
spec:html; type:element; text:script
</pre>

<pre class="anchors">
spec: STRUCTURED-HEADERS; type: dfn; urlPrefix: https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#
  text: parsing a structured header; url: text-parse
  text: parameters; for: structured header; url: param
  text: string; for: structured header; url: string
  text: token; for: structured header; url: token
  text: dictionary; for: structured header; url: dictionary
  text: inner list; for: structured header; url: inner-list
spec: FEATURE-POLICY; type: dfn; urlPrefix: https://w3c.github.io/webappsec-feature-policy/
  text: feature policy directive; url: policy-directive
  text: parsing a feature policy directive; url: parse-policy-directive
  text: create a feature policy for a browsing context; url: create-for-browsingcontext
  text: create a feature policy from a response; url: create-from-response
  text: process response policy; url: process-response-policy; for: feature policy
  text: merge directive with declared policy; url: merge-directive-with-declared-policy; for: feature policy
  text: parse header from value and origin; url: parse-header-from-value-and-origin; for: feature policy
spec: CSP; type: dfn; urlPrefix: https://w3c.github.io/webappsec-csp/
  text: set response's CSP list; url: set-response-csp-list
spec: RFC6797; urlPrefix: https://tools.ietf.org/html/rfc6797
  type: http-header
    text: Strict-Transport-Security; url: section-6.1
</pre>

<h2 id="intro">Introduction</h2>

<div nonnormative>

Developers set a number of properties associated with resources on an [=/origin=] by delivering resource-specific HTTP response headers and <{meta}> elements. This is becoming more common over time, and it's quite normal these days to see multiple kilobytes at the beginning of every response dedicated to such metadata. Setting this metadata is valuable indeed, as it can have a large impact on performance, security, and privacy.

However, the existing delivery mechanism is ill-suited to the task, suffering from a clear mismatch between the resource-specific nature of the metadata declarations on the one hand, and the origin-wide intent of the metadata on the other. Take `<a http-header><code>Strict-Transport-Security</code></a>`, for example, which explicitly alters the state of an entire origin, but is delivered as a resource-specific response header. [[RFC6797]]

Moreover, many resource-specific headers are deployed in such a way as to be <i lang="la">de facto</i> static across all resources that an origin serves. `<a http-header><code>Content-Security-Policy</code></a>`, for instance, can be very granular indeed, but is commonly implemented by setting a single policy which is delivered for an entire application. [[CSP]]

A number of implications follow:

1. Servers are required to repeat themselves. At length. `<a http-header><code>Content-Security-Policy</code></a>` alone can easily eat multiple kilobytes of each navigational response, bandwidth which could instead be dedicated to content a user might care about. This has obvious and direct impact on the delay a user experiences when navigating, but has less obvious knock-on effects that reduce performance further. HTTP/2's HPACK header compression is limited to ~4k of state for processing, for instance, meaning that these verbose headers can greatly reduce its effectiveness. [[RFC7541]]

2. Servers are required to repeat themselves. Unerringly. When policy applies strictly to a resource, and not to the origin, then a server must send that policy down with every response. If the developer forgets a page (especially common on error pages), then the policy's protections don't apply to that resource, leaving an exploitable hole.

This document introduces a new delivery mechanism for policies which are meant to apply to an entire origin. The server provides an [=origin policy manifest=] at a well-known location. This file contains origin-wide configuration metadata, which can affect all requests to and responses from that origin. Then, individual HTTP responses can instruct the user agent to download and process this manifest. Depending on the preference expressed by the server for a given resource, processing of the response can be blocked until the manifest is fetched and its policy items applied. Alternately, the server can indicate that previously-downloaded [=origin policy manifests=], or indeed no origin policy at all, are acceptable for a given resource.

</div>

<h3 id="examples">Examples</h3>

<div class="example" id="example-initial-policy">
  MegaCorp, Inc. wishes to ensure that a baseline [=/content security policy=] is applied to each of the pages on <code>https://example.com</code>, while avoiding the overhead associated with large response headers, and the uncertainty that they've really covered everything that lives on the origin.

  The first thing MegaCorp does is ensure that <code>https://example.com/.well-known/origin-policy</code> serves an appropriate policy. They place a UTF-8 encoded JSON file at that location, containing the following:

  <pre highlight="json">
  {
    "<a for="origin policy manifest">ids</a>": ["policy-1"],
    "<a for="origin policy manifest">content_security</a>": {
      "<a for="origin policy manifest/content_security">policies</a>": ["<a>script-src</a> 'self' https://cdn.example.com"]
    }
  }
  </pre>

  They then modify all responses from their origin to contain a `<a http-header><code>Origin-Policy</code></a>` header requiring that this policy be fetched and applied. For example, given:

  <pre>
  GET / HTTP/1.1
  Host: example.com
  Connection: keep-alive
  ...
  </pre>

  the server can respond with

  <pre>
  HTTP/1.1 200 OK
  Content-Type: text/html
  ...
  <a http-header>Origin-Policy</a>: allowed=("policy-1")
  ...
  </pre>

  Upon seeing the `<a http-header><code>Origin-Policy</code></a>` header, the browser will check if it has a cached origin policy for <code>https://example.com/</code>, with "<code>policy-1</code>" as one of its [=origin policy/IDs=]. For this first request, no such cache entry is found. Since the [=null policy=] is not in the header's <code>allowed</code> list, this means that although the browser can continue to download the response body, further processing of the response (in this case [=navigate|navigation=]) is blocked on retrieving and applying the origin policy. So the browser does that:

  <pre>
  GET /.well-known/origin-policy HTTP/1.1
  Host: example.com
  Connection: keep-alive
  ...
  </pre>

  and gets back

  <pre>
  HTTP/1.1 200 OK
  Content-Type: application/originpolicy+json
  Cache-Control: max-age=86400
  ... response body as above ...
  </pre>

  The navigation to <code>https://example.com/</code> then proceeds as normal, with the [=/content security policy=] indicated in the [=origin policy manifest=] applied.
</div>

<div class="example" id="example-repeat-visit">
  From the landing page at <code>https://example.com/</code>, the user clicks a link and navigates to <code>https://example.com/about</code>. The request and response headers are the same as in the previous example, but this time the browser handles things a bit differently.

  This time, when the browser goes to look for "<code>policy-1</code>", it finds a matching policy in the HTTP cache. (We're assuming here that less than 86400 seconds have passed.) So no requests to <code>https://example.com/.well-known/origin-policy</code> need to be made, and the response for <code>https://example.com/about</code> can be immediately processed, with the origin policy applied.
</div>

<div class="example" id="example-third-party">
  GigaCorp, Inc., located at <code>https://example.net</code>, wishes to include a widget from MegaCorp on their page. They embed it using an <{iframe}>:

  <xmp highlight="html">
    <iframe src="https://example.com/widget"></iframe>
  </xmp>

  When a user visits <code>https://example.net</code>, the subresource request for <code>https://example.com/widget</code> goes through the same origin policy retrieval process as in <a href="#example-initial-policy">the first visit</a>. Note that this is true <em>even if the user has already visited <code>https://example.com</code></em>, because origin policies are stored in the HTTP cache, which is <a href="https://github.com/whatwg/fetch/pull/943">partitioned</a> by top-level origin. <!-- TODO xref top-level origin when it's defined --> That is, there is no cache entry for <code>https://example.com/.well-known/origin-policy</code> in the HTTP cache partition corresponding to <code>https://example.net</code>. See [[#tracking]] for more on why this is the case.

  But the HTTP cache still helps: repeat visits to <code>https://example.net</code> will be able to use the <code>https://example.com/.well-known/origin-policy</code> cache entry in the <code>https://example.net</code> cache partition, and avoid fetching the origin policy for the embedded <{iframe}>.
</div>

<div class="example" id="example-policy-update">
  <!-- TODO will this become document policy? -->
  MegaCorp., Inc. is interested in removing all uses of synchronous {{XMLHttpRequest}} from their site. They think they've got them all, but they'd like to roll out a report-only [=feature policy=] to be sure.

  They update their [=origin policy manifest=] to include such reporting:

  <pre highlight="json">
  {
    "<a for="origin policy manifest">ids</a>": ["policy-1"],
    "<a for="origin policy manifest">content_security</a>": {
      "<a for="origin policy manifest/content_security">policies</a>": ["<a>script-src</a> 'self' https://cdn.example.com"]
    },
  <mark>  "<a for="origin policy manifest">features</a>": {
      "policy_report_only": "<a spec="xhr">sync-xhr</a> 'none'"
    }</mark>
  }
  </pre>

  New visitors to their site, who download the origin policy manifest for the first time, will get this updated policy, and thus their browsers will report any synchronous XHRs. The same is true for visitors whose cache entry for the origin policy manifest expires, once they re-fetch the updated one. But can we do better?

  Yes, we can! The trick is to leverage the [=origin policy/IDs|policy IDs=] mechanism. First, update the manifest with a new ID:

  <pre highlight="json">
  {
  <mark>  "<a for="origin policy manifest">ids</a>": ["policy-2"]</mark>,
    "<a for="origin policy manifest">content_security</a>": {
      "<a for="origin policy manifest/content_security">policies</a>": ["<a>script-src</a> 'self' https://cdn.example.com"]
    },
    "<a for="origin policy manifest">features</a>": {
      "policy_report_only": "<a spec="xhr">sync-xhr</a> 'none'"
    }
  }
  </pre>

  Then, change the `<a http-header><code>Origin-Policy</code></a>` response header to indicate that this new policy is preferred:

  <pre>
  <a http-header>Origin-Policy</a>: preferred="policy-2", allowed=("policy-1")
  </pre>

  When the browser sees this header value on any response from <code>https://example.com</code>, one of three things will happen:

  * It will have no origin policy cached for <code>https://example.com</code>. Then, the browser will fetch <code>https://example.com/.well-known/origin-policy</code> before processing the response, and get the result, which has "<code>policy-2</code>" as one of its [=origin policy/IDs=]. Thus the response will be loaded with the feature policy applied.

  * It will have the previous policy, with <code>"ids": ["policy-1"]</code>, cached. In this case, because "<code>policy-1</code>" is in the <code>allowed</code> list, it applies the previous policy to the resource being loaded, without blocking response processing on any origin policy fetches. This means the feature policy does not apply to the loaded resource. But because "<code>policy-2</code>" was marked as <code>preferred</code>, the browser will additionally fetch <code>https://example.com/.well-known/origin-policy</code> to update its cache entry, so that any future fetches for <code>https://example.com</code> can benefit from the newest revision, and have the feature policy applied.

  * It will have the new policy, with <code>"ids": ["policy-2"]</code>, cached. In this case, the <code>preferred</code> policy is available, so the browser uses that, and does not need to bother re-fetching the origin policy manifest.

  In this way, MegaCorp can deploy the new origin policy even to clients within the 24-hour <code>max-age</code> window for the origin policy resource, without incurring any extra fetches if the good-enough previous policy is available for immediate use.
</div>

<div class="example" id="example-policy-multiple-ids">
  The above example has a flaw when combined with cached resources. Consider the case where the user has previously visited <code>https://example.com/static-page.html</code>, which was delivered with headers such as

  <pre>
  HTTP/1.1 200 OK
  Content-Type: text/html
  ...
  <a http-header>Origin-Policy</a>: allowed=("policy-1")
  Cache-Control: max-age=31536000
  ...
  </pre>

  i.e. the page was cached for a year.

  If the user re-visits this URL, then the page will be loaded from the cache. But the cached page does not allow "<code>policy-2</code>", which is the only [=origin policy/ID=] found in the current origin policy at <code>https://example.com/.well-known/origin-policy</code>. It only allows "<code>policy-1</code>".

  As with all origin policy mismatches, this will cause a re-fetch of the origin policy to try to find a new policy that matches the one requested by the `<a http-header><code>Origin-Policy</code></a>` header. (We saw this previously on <a href="#example-initial-policy">the first visit</a>, when the page requested "<code>policy-1</code>" but the current policy for the origin was the [=null policy=].) But in this case, such a request will just return the same origin policy manifest, with <code>"ids": ["policy-2"]</code>. Thus, <code>https://example.com/static-page.html</code> will fail to load.

  To fix this, the server operator can instead update their origin policy as follows:

  <pre highlight="json">
  {
  <mark>  "<a for="origin policy manifest">ids</a>": ["policy-1", "policy-2"]</mark>,
    "<a for="origin policy manifest">content_security</a>": {
      "<a for="origin policy manifest/content_security">policies</a>": ["<a>script-src</a> 'self' https://cdn.example.com"]
    },
    "<a for="origin policy manifest">features</a>": {
      "policy_report_only": "<a spec="xhr">sync-xhr</a> 'none'"
    }
  }
  </pre>

  This would mean that the new origin policy is able to be applied even when "<code>policy-1</code>" is requested, such as in the case of our cached static page.

  The general rule here is that when adding a new value to the "<code><a for="origin policy manifest">ids</a></code>" field of their origin policy manifest, server operators will be best served by keeping any previous [=origin policy/IDs=] as well, at least until any cached resources that reference that origin policy could have expired.
</div>

<div class="example" id="example-null">
  MegaCorp has noticed that first-time visitors to their site, as in <a href="#example-initial-policy">the example above</a>, are having a suboptimal experience, with their responses being blocked by an additional round-trip to fetch the origin policy. Upon reflection, MegaCorp realizes that first-time visitors probably don't need origin policies applied. All of their site's exciting stuff is hidden behind a login wall, which involves at least one navigation. So it would be fine to omit the origin policy for such initial responses, as long as it gets applied on post-login responses.

  To express this, MegaCorp modifies their response header to

  <pre>
  <a http-header>Origin-Policy</a>: preferred="policy-2", allowed=("policy-1" <mark>null</mark>)
  </pre>

  This indicates that the [=null origin policy=] is acceptable, if both "<code>policy-1</code>" and "<code>policy-2</code>" are not cached, and thus allows responses to initial visitors to proceed without blocking on fetching an origin policy. But, because there is a <code>preferred</code> value, in such cases the browser will also do a non-blocking fetch to <code>https://example.com/.well-known/origin-policy</code>, to update the HTTP cache for any future requests to <code>https://example.com/</code>.

  MegaCorp could even vary their `<a http-header><code>Origin-Policy</code></a>` header dynamically between this fast-but-permissive version and the previous blocking-and-strict version, depending on characteristics of the request such as [=credentials=].
</div>

<div class="example" id="example-latest">
  MegaCorp is downsizing, and can no longer spare headcount for a dedicated Origin Policy Specialist to carefully maintain their origin policy manifest's "<code><a for="origin policy manifest">ids</a></code>" field, and their `<a http-header><code>Origin-Policy</code></a>` header <code>allowed</code> and <code>preferred</code> values. They just want to perform updates to their origin policy manifest, and have them rolled out to their visitors as soon as is possible.

  To make this work, they change all their response headers to

  <pre>
  <a http-header>Origin-Policy</a>: preferred=latest-from-network, allowed=(latest null)
  </pre>

  which will ensure that browser uses the latest origin policy available from the cache, if any, or the [=null origin policy=], if nothing is cached. Furthermore, the <code>preferred=latest-from-network</code> part of the header ensures that the browser will always perform a non-blocking fetch to <code>https://example.com/.well-known/origin-policy</code> to update the HTTP cache.

  This is slightly less efficient than the previous version. And, it doesn't allow expressing constraints on the contents of policies, by matching preferred and allowed values with the manifest's "<code><a for="origin policy manifest">ids</a></code>" field. But, it is simpler to maintain.
</div>

<div class="example" id="example-killswitch">
  MegaCorp wishes to remove the origin policy, and ensure that any visitors to its site no longer get any of its effects. It can do so by using the following `<a http-header><code>Origin-Policy</code></a>` response header:

  <pre>
  <a http-header>Origin-Policy</a>: allowed=(null)
  </pre>

  When the browser receives this header, it will ensure that no origin policy is applied for the response, since only the [=null policy=] is allowed.
</div>

</div>

<h2 id="framework">Framework</h2>

<h3 id="origin-policy-header">The `<code>Origin-Policy</code>` HTTP header</h3>

The `<dfn http-header><code>Origin-Policy</code></dfn>` response [=header=] can be used to indicate the allowed and preferred [=/origin policy=] used when processing a [=response=]. It may be sent on any HTTP response, in order to update the user agent's record of a given [=/origin=]'s [=/origin policy=].

`<a http-header><code>Origin-Policy</code></a>` is a [=structured header/dictionary=] structured header. The dictionary has two keys: [[!STRUCTURED-HEADERS]]

* <code>allowed</code>, whose value is an [=structured header/inner list=] that contains [=valid origin policy IDs=] as strings, or the token <code>null</code>, or the token <code>latest</code>; and
* <code>preferred</code>, whose value is either a [=valid origin policy ID=], or the token <code>latest-from-network</code>.

At least one of these two entries needs to be provided for the header to have useful behavior.

<p class="note">If an ID is provided for <code>preferred</code>, it is unnecessary to also include it in the <code>allowed</code> list.</p>

This specification does not currently use [=structured header/parameters=] in any locations within the structured header it defines.

The processing model for this header, including the fallback behavior for when it is not provided or does not conform to the above data model, is given in [[#from-response]]. In general, the fallback behavior for malformed headers is to behave the same as if `<code>Origin-Policy: allowed=(null)</code>` is sent, and thus use the [=null origin policy=] for processing the [=response=]. The processing model for omitting the header is to use any previously-cached [=/origin policy=] for the [=/origin=].

<h3 id="manifest-file">The origin policy manifest</h3>

The <dfn>origin policy manifest</dfn> is a JSON-formatted document consisting of a top-level object with one or more members. Its [=MIME type=] is <dfn export><code>application/originpolicy+json</code></dfn>, and it is always treated as [=UTF-8=].

<div class="example" id="example-manifest-structure">
  <pre highlight="json">
  {
    "<a for="origin policy manifest">ids</a>": ["my-policy"],
    "<a for="origin policy manifest">features</a>": {
      "<a for="origin policy manifest/features">policy</a>": "fullscreen 'none'; geolocation 'none'"
    },
    "<a for="origin policy manifest">content_security</a>": {
      "<a for="origin policy manifest/content_security">policies</a>": ["<a>frame-ancestors</a> 'none'", "<a>object-src</a> 'none'"],
      "<a for="origin policy manifest/content_security">policies_report_only</a>": ["<a>script-src</a> 'self' https://cdn.example.com/js/"]
    }
  }
  </pre>
</div>

This section gives an overview of the file format, as well authoring requirements. The processing model for the manifest, including how to deal with violations of these authoring requirements, are handled by the algorithms in [[#parsing]].

<h4 id="manifest-ids">The "<code>ids</code>" member</h4>

The "<dfn for="origin policy manifest"><code>ids</code></dfn>" member defines the [=origin policy/IDs=] of the [=/origin policy=]. These are used, in conjunction with the `<a http-header><code>Origin-Policy</code></a>` header, to allow [=/origins=] to express their preferences and requirements among any previously-cached revisions of the [=origin policy manifest=].

It must be present, and must be an array containing only [=valid origin policy ID=] strings. At least one such string must be present in the array.

<h4 id="policy-item-features">The "<code>features</code>" policy item</h4>

The "<dfn for="origin policy manifest"><code>features</code></dfn>" member defines the baseline [=feature policy=] to apply to any responses from the origin.

If present, it must be an object, with one possible key: "<dfn for="origin policy manifest/features"><code>policy</code></dfn>". The "<code>policy</code>" sub-member's value must be a string that matches the <a spec="FEATURE-POLICY"><code>serialized-feature-policy</code></a> production. [[!FEATURE-POLICY]]

<p class="note">Although the `<a http-header><code>Feature-Policy</code></a>` header tolerates using commas as a separator, that is an artifact of the HTTP header serialization, and commas will cause parsing failures inside an [=origin policy manifest=].</p>

As per the processing model in [[#monkeypatch-fp]], feature policy directives supplied here serve as a baseline, which the `<a http-header><code>Feature-Policy</code></a>` header on individual responses can override on an individual feature basis.

<div class="example" id="example-feature-policy">
  If a [=response=] is processed with the [=origin policy manifest=] given by

  <pre highlight="json">
  {
    "<a for="origin policy manifest">ids</a>": ["my-policy"],
    "<a for="origin policy manifest">features</a>": {
      "<a for="origin policy manifest/features">policy</a>": "fullscreen 'self'; geolocation 'none'"
    }
  }
  </pre>

  and the `<a http-header><code>Feature-Policy</code></a>` header

  <pre>
    <a http-header>Feature-Policy</a>: fullscreen https://example.com; camera 'self'
  </pre>

  then the resulting {{Document}}'s <a for="Document" spec="HTML">feature policy</a> will be «[ "fullscreen" → «https://example.com/», "geolocation" → «'none'», "camera" → «'self'» ]». Note how the allowlists are overwritten; they do not combine.
</div>

<h4 id="policy-item-content_security">The "<code>content_security</code>" policy item</h4>

The "<dfn for="origin policy manifest"><code>content_security</code></dfn>" member defines zero or more [=/content security policies=] to apply to any responses from the origin.

If present, it must be an object, with two possible keys: "<dfn for="origin policy manifest/content_security"><code>policies</code></dfn>" and "<dfn for="origin policy manifest/content_security"><code>policies_report_only</code></dfn>". Both sub-members' values must be arrays containing zero or more strings, where the strings match the [=serialized CSP=] production. [[!CSP]]

<p class="note">Although the `<a http-header><code>Content-Security-Policy</code></a>` and `<a http-header><code>Content-Security-Policy-Report-Only</code></a>` headers tolerate using commas as a separator, that is an artifact of the HTTP header serialization, and commas will cause parsing failures inside an [=origin policy manifest=]. Instead, [=CSP lists=] are represented as arrays, so if you wish to use multiple [=/content security policies=], include them as multiple array members.</p>

As per the processing model in [[#monkeypatch-csp]], content security policies supplied here are applied before any from the `<a http-header><code>Content-Security-Policy</code></a>`/`<a http-header><code>Content-Security-Policy-Report-Only</code></a>` headers on individual responses. When used together, they combine  the usual manner for multi-item [=CSP lists=].

<div class="example" id="example-csp">
  If a [=response=] is processed with the [=origin policy manifest=] given by

  <pre highlight="json">
  {
    "<a for="origin policy manifest">ids</a>": ["my-policy"],
    "<a for="origin policy manifest">content_security</a>": {
      "<a for="origin policy manifest/content_security">policies</a>": ["<a>script-src</a> cdn.example.org 'unsafe-inline'; <a>object-src</a> 'none'"]
    }
  }
  </pre>

  and the `<a http-header><code>Content-Security-Policy</code></a>` header

  <pre>
    <a http-header>Content-Security-Policy</a>: <a>script-src</a> 'nonce-random123' 'strict-dynamic' 'unsafe-inline' https:
  </pre>

  then the resulting {{Document}}'s [=Document/CSP list=] will contain two separate [=content security policy object|content security policies=], with the combined effect of only allowing scripts which match both policies. In this case, it will accept scripts with a nonce of <code>random123</code> (per the header policy) which are either inline <{script}> blocks or come from <code>cdn.example.org</code> (per the origin policy).
</div>

<h3 id="origin-policy-well-known">The <code>origin-policy</code> well-known URL</h3>

[=Origin policy manifests=] for a given [=/origin=] are located at the well-known URL <code>/.well-known/origin-policy</code>. [[!RFC8615]]

Servers who wish to provide an origin policy will need to respond to `<code>GET</code>` [=requests=] to this URL with the contents of their [=origin policy manifest=], including setting the correct value of <a><code>application/originpolicy+json</code></a> for the response's `<code>Content-Type</code>` header.

The usual caching strategies (e.g. long <code>max-age</code>, or using the `<code>Etag</code>` header) are quite useful in conjunction with the <code>/.well-known/origin-policy</code> resource, especially since the `<a http-header><code>Origin-Policy</code></a>` header can be used to force a cache refresh.

The processing model for how browsers send [=requests=] to this URL is given in [[#updating]].

<h2 id="data-model">Data model</h2>

An <dfn>origin policy</dfn> is a [=struct=] containing the following [=struct/items=]:

: <dfn for="origin policy">IDs</dfn>
:: A [=list=] of [=/strings=] which are each a [=valid origin policy ID=].
: <dfn for="origin policy">feature policy</dfn>
:: A [=feature policy directive=]. [[!FEATURE-POLICY]]
: <dfn for="origin policy">content security policies</dfn>
:: A [=list=] of [=content security policy object|content security policies=]. [[!CSP]]

The <dfn lt="null policy|null origin policy">null policy</dfn> is an [=/origin policy=] that has empty lists for its [=origin policy/IDs=], [=origin policy/feature policy=], and [=origin policy/content security policies=]. As enforced by the processing model, no other policy can an empty [=origin policy/IDs=] list.

A [=/string=] is a <dfn>valid origin policy ID</dfn> if all of the following are true:

* It is not the empty string
* It only contains [=code points=] in the range U+0020 SPACE through U+007E (~), inclusive. (This is the same as the range specified to be parseable as a string via structured headers. [[STRUCTURED-HEADERS]])

<h2 id="processing-model">Processing model</h2>

The below algorithms make use of the special values <dfn>latest</dfn> and <dfn>latest-from-network</dfn>, which we use as the parsed representation of the corresponding [=structured header/tokens=] from the `<a http-header><code>Origin-Policy</code></a>` structured header.

<h3 id="from-response">Response processing</h3>

This section details the entry point algorithms, for determining which origin policy applies to an incoming [=response=].

<div algorithm>
  To <dfn lt="get the origin policy for a response|getting the origin policy for a response">get the origin policy for a response</dfn>, given a [=response=] |response| and an [=environment settings object=] |client|:

  1. If |response|'s [=response/URL=] is null, then return the [=null policy=].
  1. Let |origin| be |response|'s [=response/URL=]'s [=url/origin=].
  1. Let |header| be the result of [=header list/getting=] `<a http-header><code>Origin-Policy</code></a>` from |response|'s [=response/header list=].
  1. If |header| is null, then return the result of [=retrieving the cached origin policy=] for |origin| given |client|.
  1. Let (|allowedIds|, |preferredId|) be the result of <a>parsing an `<code>Origin-Policy</code>` header</a> given |header|. If this instead returns "<code>unparseable</code>", then return the [=null policy=].
  1. Return the result of [=fetching an origin's origin policy=] for |origin| given |client|, |allowedIds|, and |preferredId|.
</div>

<div algorithm>
  To <dfn data-lt="parse an `Origin-Policy` header|parsing an `Origin-Policy` header">parse an `<code>Origin-Policy</code>` header</dfn> given a [=byte sequence=] |headerBytes|:

  1. Let |parsedHeader| be the result of [=parsing a structured header=] given |headerBytes| and "<code>dictionary</code>". If this fails, then return "<code>unparseable</code>".
  1. Let |allowedIds| be an empty [=ordered set=].
  1. If |parsedHeader|["<code>allowed</code>"] [=map/exists=]:
    1. If |parsedHeader|["<code>allowed</code>"][0] is not a [=list=], then return "<code>unparseable</code>".
    1. Let |rawAllowedList| be |parsedHeader|["<code>allowed</code>"][0].
    1. [=For each=] |itemTuple| in |rawAllowedList|:
      1. Let |allowedId| be |itemTuple|[0].
      1. If |allowedId| is not a [=structured header/string=], the [=structured header/token=] <code>null</code>, or the [=structured header/token=] <code>latest</code>, or if |allowedId| is the empty string, then return "<code>unparseable</code>".
      1. If |allowedId| is the <code>null</code> [=structured header/token=], then set |allowedId| to null.
      1. If |allowedId| is the <code>latest</code> [=structured header/token=], then set |allowedId| to [=latest=].
      1. Assert: if |allowedId| is a string, then it is a [=valid origin policy ID=].
      1. [=set/Append=] |allowedId| to |allowedIds|.
  1. Let |preferredId| be null.
  1. If |parsedHeader|["<code>preferred</code>"] [=map/exists=]:
    1. Set |preferredId| to |parsedHeader|["<code>preferred</code>"][0].
    1. If |preferredId| is not a [=structured header/string=] or the [=structured header/token=] <code>latest-from-network</code>, or it is the empty string, then return "<code>unparseable</code>".
    1. If |preferredId| is the <code>latest-from-network</code> [=structured header/token=], then set |preferredId| to [=latest-from-network=].
    1. Assert: if |preferredId| is a string, then it is a [=valid origin policy ID=].
  1. Return the [=tuple=] (|allowedIds|, |preferredId|).

  <p class="note">The constant lookups of the 0th [=tuple/item=] in [=tuples=] above is due to the way that structured header parse results are generally packaged as tuples where the 0th item is the value of interest, and the 1st item is an associated [=ordered map=] of [=structured header/parameters=]. In all cases we ignore the parameters.</p>
</div>

<h3 id="updating">Updating the origin policy</h3>

<div algorithm>
  To <dfn lt="fetch an origin's origin policy|fetching an origin's origin policy">fetch an origin's origin policy</dfn> for an [=/origin=] |origin| given |client|, |allowedIds|, and |preferredId|:

  1. Let |cachedPolicy| be the result of [=retrieving the cached origin policy=] given |origin| and |client|.
  1. If |preferredId| is [=list/contained=] in |cachedPolicy|'s [=origin policy/IDs=], then return |cachedPolicy|.
  1. Let |url| be the result of [=getting the origin policy manifest URL=] for |origin|.
  1. If |url| is null, then return the [=null policy=].
  1. Let |networkRequest| be a new [=request=] whose [=request/url=] is |url|, [=request/client=] is |client|, [=request/service-workers mode=] is "<code>none</code>", [=request/destination=] is "<code>manifest</code>", [=request/mode=] is "<code>same-origin</code>", [=request/redirect mode=] is "<code>error</code>", [=request/credentials mode=] is "<code>omit</code>", [=request/referrer policy=] is "<code>no-referrer</code>", and [=request/cache mode=] is "<code>no-cache</code>".
  1. If |cachedPolicy| is not the [=null policy=], and either |allowedIds| [=list/contains=] one of |cachedPolicy|'s [=origin policy/IDs=], or |allowedIds| [=list/contains=] [=latest=], then:
    1. If |preferredId| is not null, then [=in parallel=], [=fetch=] |networkRequest|. (This will update the cache, but the [=response=] will not be used.)
    1. Return |cachedPolicy|.
  1. If |allowedIds| contains null, then:
    1. If |preferredId| is not null, then [=in parallel=], [=fetch=] |networkRequest|. (This will update the cache, but the [=response=] will not be used.)
    1. Return the [=null policy=].
  1. Let |networkResponse| be the result of [=fetching=] |networkRequest|. (Unlike the [=in parallel=] fetches, this is blocking.)
  1. Let |networkPolicy| be the result of [=getting an origin policy from a manifest response=] given |networkResponse|.
  1. If any of the following is true:
      * |preferredId| is [=latest-from-network=]; or
      * |preferredId| is a string, and is [=list/contained=] in |networkPolicy|'s [=origin policy/IDs=]; or
      * |allowedIds| [=list/contains=] one of |networkPolicy|'s [=origin policy/IDs=],
    then return |networkPolicy|.
  1. Return "<code>failure</code>".

  <p class="note">Although this specification uses the full [=fetching=] mechanism to check the HTTP cache for an origin policy, and then [=getting an origin policy from a manifest response|re-parses=] the result each time, implementations could use a more efficient mechanism, as long as the results are observably equivalent. In such cases, implementations ought to take particular care around respecting the cache expiration and keying semantics.</p>

  <div class="note">
    The following provides a non-normative summary of the outcomes of the above algorithm under various conditions:

    * |preferredId| matches |cachedPolicy|: use |cachedPolicy|.
    * |preferredId| mismatches |cachedPolicy| or is not provided:
      * |cachedPolicy| is the [=null policy=]:
        * |allowedIds| contains null: use the [=null policy=], and refresh the HTTP cache in the background.
        * |allowedIds| does not contain null: fetch |networkPolicy|, and use it if it matches |allowedIds| or |preferredId|.
      * |cachedPolicy| is not the [=null policy=]:
        * |allowedIds| matches one of |cachedPolicy|'s [=origin policy/IDs=]: use |cachedPolicy|, and refresh the HTTP cache in the background if |preferredId| was provided.
        * |allowedIds| does not match any of |cachedPolicy|'s [=origin policy/IDs=] but does contain null: use the [=null policy=], and refresh the HTTP cache in the background if |preferredId| was provided.
        * |allowedIds| does not match any of |cachedPolicy|'s [=origin policy/IDs=] and does not contain null: fetch |networkPolicy|, and use it if it matches |allowedIds| or |preferredId|.

    Here [=latest=] always matches a non-[=null policy|null=] |cachedPolicy| and and [=latest-from-network=] always matches a fetched |networkPolicy|.
  </div>
</div>

<!-- TODO: should this behave more like stale-while-revalidate, in particular the prevent no-cache cache-control header modification flag?-->

<div algorithm="retrieve the cached origin policy">
  To <dfn lt="retrieve the cached origin policy|retrieving the cached origin policy">retrieve the cached origin policy</dfn> for an [=/origin=] |origin| given an [=environment settings object=] |client|:

  1. Let |url| be the result of [=getting the origin policy manifest URL=] for |origin|.
  1. If |url| is null, return the [=null policy=].
  1. Let |cacheCheckRequest| be a new [=request=] whose [=request/url=] is |url|, [=request/client=] is |client|, [=request/service-workers mode=] is "<code>none</code>", [=request/destination=] is "<code>manifest</code>", [=request/mode=] is "<code>same-origin</code>", [=request/redirect mode=] is "<code>error</code>", [=request/credentials mode=] is "<code>omit</code>", and [=request/cache mode=] is "<code>only-if-cached</code>".
  1. Let |cachedResponse| be the result of [=fetching=] |cacheCheckRequest|.
  1. Return the result of [=getting an origin policy from a manifest response=] given |cachedResponse|.
</div>

<div algorithm>
  To <dfn lt="get the origin policy manifest URL|getting the origin policy manifest URL">get the origin policy manifest URL</dfn> for an [=/origin=] |origin|:

  1. If |origin| is not [=potentially trustworthy origin|potentially trusthworthy=], then return null.
  1. Return the result of [=URL parser|parsing=] the concatenation of the [=serialization of an origin|serialization=] of |origin| and "<code>/.well-known/origin-policy</code>".
</div>

<div algorithm>
  To <dfn lt="get an origin policy from a manifest response|getting an origin policy from a manifest response">get an origin policy from a response</dfn> given a [=response=] |response|:

  1. If |response|'s [=response/status=] is not an [=ok status=], then return the [=null policy=].
  1. Let |mimeType| be the result of [=extracting a MIME type=] from |response|'s [=response/header list=].
  1. If |mimeType|'s [=MIME type/essence=] is not "<code>application/originpolicy+json</code>", then return the [=null policy=].
  1. [=Wait=] for |response|'s [=response/body=].
  1. Let |string| be the result of [=UTF-8 decoding=] |response|'s [=response/body=] (treating it as a [=byte sequence=]).
  1. Return the result of [=parsing a string into an origin policy=] given |string|.
</div>

<h3 id="parsing">Parsing</h3>

This section details the parsing and validation algorithms for the JSON structure of the origin policy, i.e. turning [=strings=] into [=/origin policy=] [=structs=].

<div algorithm>
  To <dfn lt="parse a string into an origin policy|parsing a string into an origin policy">parse a string into an origin policy</dfn> given a [=string=] |string|:

  1. Let |parsed| be the result of [=parse JSON into Infra values|parsing JSON into Infra values=] given |string|. If this throws an exception, then return the [=null policy=].
  1. If |parsed| is not a [=map=], then return the [=null policy=].
  1. Let |ids| be an empty list.
  1. If |parsed|["<a for="origin policy manifest"><code>ids</code></a>"] does [=map/exists=] and is a [=list=], then [=list/for each=] |potentialId| in |parsed|["<a for="origin policy manifest"><code>ids</code></a>"]:
    1. If |potentialId| is a [=valid origin policy ID=], then [=list/append=] |potentialId| to |ids|.
  1. If |ids| [=list/is empty=], then return the [=null policy=].
  1. Let |featurePolicy| be an empty [=feature policy directive=].
  1. If |parsed|["<a for="origin policy manifest"><code>features</code></a>"] exists and is a [=map=], and |parsed|["<a for="origin policy manifest"><code>features</code></a>"]["<a for="origin policy manifest/features"><code>policy</code></a>"] exists and is a string, then set |featurePolicy| to the result of [=parsing a feature policy directive=] given |parsed|["<a for="origin policy manifest"><code>features</code></a>"]["<a for="origin policy manifest/features"><code>policy</code></a>"].
  1. Let |contentSecurityPolicies| be an empty [=list=].
  1. If |parsed|["<a for="origin policy manifest"><code>content_security</code></a>"] exists and is a [=map=], then:
    1. If |parsed|["<a for="origin policy manifest"><code>content_security</code></a>"]["<a for="origin policy manifest/content_security"><code>policies</code></a>"] exists and is a [=list=], then [=list/for each=] |potentialPolicyString| in |parsed|["<a for="origin policy manifest"><code>content_security</code></a>"]["<a for="origin policy manifest/content_security"><code>policies</code></a>"]:
      1. If |potentialPolicyString| is not a [=string=], then [=continue=].
      1. Let |policy| be the result of [$parse a serialized CSP|parsing a serialized CSP$] given |potentialPolicyString|, "<code>header</code>", and "<code>enforce</code>".
      1. If |policy|'s [=policy/directive set=] is not empty, then [=list/append=] |policy| to |contentSecurityPolicies|.
    1. If |parsed|["<a for="origin policy manifest"><code>content_security</code></a>"]["<a for="origin policy manifest/content_security"><code>policies_report_only</code></a>"] exists and is a [=list=], then [=list/for each=] |potentialPolicyString| in |parsed|["<a for="origin policy manifest"><code>content_security</code></a>"]["<a for="origin policy manifest/content_security"><code>policies_report_only</code></a>"]:
      1. If |potentialPolicyString| is not a [=string=], then [=continue=].
      1. Let |policy| be the result of [$parse a serialized CSP|parsing a serialized CSP$] given |potentialPolicyString|, "<code>header</code>", and "<code>report</code>".
      1. If |policy|'s [=policy/directive set=] is not empty, then [=list/append=] |policy| to |contentSecurityPolicies|.
  1. Return a new [=/origin policy=] whose [=origin policy/IDs=] is |ids|, [=origin policy/feature policy=] is |featurePolicy|, and [=origin policy/content security policies=] is |contentSecurityPolicies|.
</div>

<h2 id="monkeypatches">Patches to other specifications</h2>

The following patches to other specifications would be incorporated as appropriate once this specification graduates from incubation.

<h3 id="monkeypatch-fetch">Fetch</h3>

Every [=response=] gets an associated <dfn for="response">origin policy</dfn>, which is an [=/origin policy=]. It is initially the [=null origin policy=].

The <a spec="FETCH">main fetch</a> algorithm is modified by inserting the following step after step 10. (This is after headers have been received and much of the other preliminaries processed, but the request body is likely still downloading.)

1. Let |originPolicy| be the result of [=getting the origin policy for a response=] given |internalResponse| and <var ignore>request</var>'s [=request/client=].
1. If |originPolicy| is "<code>failure</code>", then set <var ignore>response</var> and |internalResponse| to a [=network error=].
1. Otherwise, set |internalResponse|'s [=response/origin policy=] to |originPolicy|.

<h3 id="monkeypatch-fp">Feature Policy</h3>

The [=feature policy/process response policy=] and algorithm needs to be replaced with the following, given a [=response=] |response| and [=/origin=] |origin|:

1. Let |policy| be a [=list/clone=] of |response|'s [=response/origin policy=]'s [=origin policy/feature policy=].
1. Let |header| be the concatenation of the [=header/values=] of all [=header=] fields in |response|'s [=response/header list=] whose name is `<a http-header><code>Feature-Policy</code></a>`, separated by U+002C (,) (according to [RFC7230, 3.2.2]).
1. For each |element| returned by <a lt="split on commas">splitting |header| on commas</a>:
  1. Let |directive| be the result of [=parsing a feature policy directive=] given |element| and |origin|.
  1. Perform [=feature policy/merge directive with declared policy=] given |directive| and |policy|.
1. Return |policy|.

<p class="note">The [=feature policy/parse header from value and origin=] sub-algorithm is no longer necessary; its contents were inlined into the above rewrite.</p>

<h3 id="monkeypatch-csp">Content Security Policy</h3>

The <a spec="CSP">set response's CSP list</a> algorithm needs its step 1 replaced with the following:

1. Set |response|'s [=response/CSP list=] to a [=list/clone=] of |response|'s [=response/origin policy=]'s [=origin policy/content security policies=].

(The rest of the algorithm will then append to this list.)

<h2 id="privacy-and-security">Privacy and security considerations</h2>

<h3 id="tracking">Tracking</h3>

The use of HTTP responses and the HTTP cache as the source of truth for origin policies, as outlined in [[#updating]], brings with it the usual privacy considerations related to the HTTP cache. In particular, to avoid using an origin policy as a tracking vector, user agents need to implement the full HTTP cache semantics for origin policies, including recent innovations such as <a href="https://github.com/whatwg/fetch/issues/904">double-keying</a>. Similarly, user agents need to ensure that when the user clears their HTTP cache entries for an origin, any cached origin policies are similarly cleared.

We mention these concerns here because although the processing model uses the HTTP cache directly, we anticipate that implementations might use a separate storage mechanism for origin policies behind the scenes, e.g. for performance reasons. That is, these concerns are taken care of automatically at the specification level, but might require extra care while implementing.

<h3 id="well-known-security">The use of a well-known URL</h3>

This specification forces the [=origin policy manifest=] to live at a specific URL, <code>/.well-known/origin-policy</code>. Compared to using a configurable location, this choice enhances security.

In particular, the action of setting a policy for an entire origin is an action that should involve the folks responsible for running the origin's server, as it has cross-cutting effects upon every application hosted on an origin. That is, the use of a well-known URL ensures that individual web application developers, without access to the entire server and its configuration, cannot interfere with other web applications running on that same origin.

Consider, for example, MegaCorp, Inc.'s <code>https://example.com</code>, which hosts a mail application, a mapping application, a document editing application, and so on. It would be unfortunate indeed if one of these applications accidentally pinned a policy to the entire origin which didn't account for the rest of the origin's contents. To mitigate that risk, this specification forces the manifest to live in a shared location for all of <code>https://example.com</code>. The goal is explicitly to elicit the kind of discussion and compromise within an origin that needs to happen in order to deploy an origin policy safely.

<h2 id="iana">IANA Considerations</h2>

<h3 id="iana-header">The `<code>Origin-Policy</code>` header</h3>

This section provides the provisional registration of the [=header=] `<a http-header><code>Origin-Policy</code></a>` in accordance with <cite>Registration Procedures for Message Header Fields</cite>. [[!RFC3864]]

: Header field name
:: <code>Origin-Policy</code>
: Applicable protocol
:: http
: Status
:: standard
: Author/Change controller
:: WICG
: Specification document(s)
:: <a href="https://wicg.github.io/origin-policy/">https://wicg.github.io/origin-policy/</a> (see [[#origin-policy-header]])

<h3 id="iana-mime-type">The <code>application/originpolicy+json</code> MIME type</h3>

This section provides the provisional registration of the [=MIME type=] <a><code>application/originpolicy+json</code></a> in accordance with <cite>Media Type Specifications and Registration Procedures</cite>. [[!RFC6838]]

: Type name
:: <code>application</code>
: Subtype name
:: <code>originpolicy+json</code>
: Required parameters
:: N/A
: Optional parameters
:: N/A
: Encoding considerations
:: 8bit (always UTF-8)
: Security considerations
:: See [[#privacy-and-security]]
: Interoperability considerations
:: TODO
: Published specification
:: <a href="https://wicg.github.io/origin-policy/">https://wicg.github.io/origin-policy/</a> (see [[#manifest-file]])
: Applications that use this media type
:: Web browsers
: Fragment identifier considerations
:: N/A
: Additional information
  <dd>
    <dl>
      : Deprecated alias names for this type
      :: N/A
      : Magic number(s)
      :: N/A
      : File extension(s)
      :: None. Often these files will be named <code>origin-policy</code> (with no extension) on typical server setups.
      : Macintosh file type code
      :: Same as for <code>application/json</code> [[!RFC8259]]
    </dl>
  </dd>
: Person & email address to contact for further information
:: Domenic Denicola <a href="mailto:d@domenic.me">d@domenic.me</a>
: Intended usage
:: Common
: Restrictions on usage
:: No restrictions apply.
: Change controller
:: WICG

<h3 id="iana-well-known">Well-known <code>origin-policy</code> URI</h3>

This section provides the provisional registration of the <code>origin-policy</code> well-known URI in the Well-Known URIs registry in accordance with <cite>Well-Known Uniform Resource Identifiers (URIs)</cite>. [[!RFC8615]]

<p class="note">Although the rest of this specification, and indeed the rest of the web platform, <a href="https://url.spec.whatwg.org/#url-apis-elsewhere">uses the term "URL"</a>, this section in particular intersects with a community that uses the term "URI".</p>

: URI suffix
:: <code>origin-policy</code>
: Change controller
:: WICG
: Specification document(s)
:: <a href="https://wicg.github.io/origin-policy/">https://wicg.github.io/origin-policy/</a> (see [[#origin-policy-well-known]])
: Related information
:: N/A

<h2 id="ack">Acknowledgments</h2>

Thanks to Mark Nottingham for his <cite>Site-Wide HTTP Headers</cite> draft, which provided inspiration. Likewise, Takeshi Yoshino's <cite>Origin-Wide CORS</cite> proposal attempts to address some of the same problems as origin policy. [[SITE-WIDE-HEADERS]] [[ORIGIN-WIDE-CORS]]

Thanks to
Anne van Kesteren,
Daniel Hausknecht,
Daniel Vogelheim,
Eric Portis,
Jeffrey Yasskin,
Mark Nottingham, and
Nihanth Subramanya
for being awesome!
