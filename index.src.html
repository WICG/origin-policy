<pre class="metadata">
Title: Origin Policy
Status: CG-DRAFT
Group: WICG
Repository: WICG/origin-policy
Shortname: origin-policy
Level: None
URL: https://wicg.github.io/origin-policy/
Editor: Domenic Denicola, Google https://www.google.com/, d@domenic.me, https://domenic.me/
Former Editor: Mike West 56384, Google https://www.google.com/, mkwst@google.com
Abstract:
  This specification defines a delivery mechanism for a number of policies
  which are to be applied to an entire origin. It complements header-based
  delivery mechanisms for existing policies (Content Security Policy,
  Referrer Policy, etc).
Indent: 2
Default Biblio Status: current
Boilerplate: omit conformance, omit feedback-header
Complain About: accidental-2119 yes, missing-example-ids yes
Markup Shorthands: css no
!Participate: <a href="https://github.com/WICG/origin-policy">GitHub WICG/origin-policy</a> (<a href="https://github.com/WICG/origin-policy/issues/new">new issue</a>, <a href="https://github.com/WICG/origin-policy/issues?state=open">open issues</a>)
</pre>

<pre class="biblio">
{
  "STRUCTURED-HEADERS": {
    "authors": ["Mark Nottingham", "Poul-Henning Kamp"],
    "href": "https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html",
    "title": "Structured Headers for HTTP",
    "status": "ID",
    "publisher": "IETF"
  },
  "SITE-WIDE-HEADERS": {
      "href": "https://mnot.github.io/I-D/site-wide-headers/",
      "title": "Site-Wide HTTP Headers",
      "authors": ["Mark Nottingham"]
  },
  "ORIGIN-WIDE-CORS": {
      "href": "https://github.com/tyoshino/origin-wide-cors/blob/master/README.md",
      "title": "Origin-Wide CORS",
      "authors": ["Takeshi Yoshino"]
  }
}
</pre>

<pre class="link-defaults">
spec:infra; type:dfn; text:list
spec:infra; type:dfn; for:/; text:string
spec:infra; type:dfn; for:list; text:for each
spec:fetch; type:dfn; for:/; text:request
spec:fetch; type:dfn; for:/; text:fetch
spec:fetch; type:dfn; for:/; text:response
spec:csp; type:dfn; for:/; text:csp list
spec:html; type:element; text:script
</pre>

<pre class="anchors">
spec: STRUCTURED-HEADERS; type: dfn; urlPrefix: https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#
  text: parsing a structured header; url: text-parse
  text: parameters; for: structured header; url: param
  text: string; for: structured header; url: string
  text: token; for: structured header; url: token
  text: dictionary; for: structured header; url: dictionary
  text: inner list; for: structured header; url: inner-list
spec: FEATURE-POLICY; type: dfn; urlPrefix: https://w3c.github.io/webappsec-feature-policy/
  text: feature policy directive; url: policy-directive
  text: parsing a feature policy directive; url: parse-policy-directive
  text: create a feature policy for a browsing context; url: create-for-browsingcontext
spec: CSP; type: dfn; urlPrefix: https://w3c.github.io/webappsec-csp/
  text: set response's CSP list; url: set-response-csp-list
spec: RFC6797; urlPrefix: https://tools.ietf.org/html/rfc6797
  type: http-header
    text: Strict-Transport-Security; url: section-6.1
spec: RFC7231; urlPrefix: https://tools.ietf.org/html/rfc7231
  type: http-header
    text: Vary; url: section-7.1.4
</pre>

<h2 id="intro">Introduction</h2>

<div nonnormative>

Developers set a number of properties associated with resources on an [=/origin=] by delivering resource-specific HTTP response headers and <{meta}> elements. This is becoming more common over time, and it's quite normal these days to see multiple kilobytes at the beginning of every response dedicated to such metadata. Setting this metadata is valuable indeed, as it can have a large impact on performance, security, and privacy.

However, the existing delivery mechanism is ill-suited to the task, suffering from a clear mismatch between the resource-specific nature of the metadata declarations on the one hand, and the origin-wide intent of the metadata on the other. Take `<a http-header><code>Strict-Transport-Security</code></a>`, for example, which explicitly alters the state of an entire origin, but is delivered as a resource-specific response header. [[RFC6797]]

Moreover, many resource-specific headers are deployed in such a way as to be <i lang="la">de facto</i> static across all resources that an origin serves. `<a http-header><code>Content-Security-Policy</code></a>`, for instance, can be very granular indeed, but is commonly implemented by setting a single policy which is delivered for an entire application. [[CSP]]

A number of implications follow:

1. Servers are required to repeat themselves. At length. `<a http-header><code>Content-Security-Policy</code></a>` alone can easily eat multiple kilobytes of each navigational response, bandwidth which could instead be dedicated to content a user might care about. This has obvious and direct impact on the delay a user experiences when navigating, but has less obvious knock-on effects that reduce performance further. HTTP/2's HPACK header compression is limited to ~4k of state for processing, for instance, meaning that these verbose headers can greatly reduce its effectiveness. [[RFC7541]]

2. Servers are required to repeat themselves. Unerringly. When policy applies strictly to a resource, and not to the origin, then a server must send that policy down with every response. If the developer forgets a page (especially common on error pages), then the policy's protections don't apply to that resource, leaving an exploitable hole.

This document introduces a new delivery mechanism for policies which are meant to apply to an entire origin. The server provides an [=origin policy manifest=] at a well-known location. This file contains origin-wide configuration metadata, which can affect all requests to and responses from that origin. Then, individual HTTP responses can instruct the user agent to download and process this manifest. Depending on the preference expressed by the server for a given resource, processing of the response can be blocked until the manifest is fetched and its policy items applied. Alternately, the server can indicate that previously-downloaded [=origin policy manifests=], or indeed no origin policy at all, are acceptable for a given resource.

</div>

<h3 id="examples">Examples</h3>

<div class="example" id="example-initial-policy">
  MegaCorp, Inc. wishes to ensure that a baseline [=/content security policy=] is applied to each of the pages on <code>https://example.com</code>, while avoiding the overhead associated with large response headers, and the uncertainty that they've really covered everything that lives on the origin.

  The first thing MegaCorp does is ensure that <code>https://example.com/.well-known/origin-policy</code> serves an appropriate policy. They place a UTF-8 encoded JSON file at that location, containing the following:

  <pre highlight="json">
  {
    "<a for="origin policy manifest">ids</a>": ["policy-1"],
    "<a for="origin policy manifest">content_security</a>": {
      "<a for="origin policy manifest/content_security">policies</a>": ["<a>script-src</a> 'self' https://cdn.example.com"]
    }
  }
  </pre>

  They then modify all responses from their origin to contain a `<a http-header><code>Origin-Policy</code></a>` header requiring that this policy be fetched and applied. For example, given:

  <pre>
  GET / HTTP/1.1
  Host: example.com
  Connection: keep-alive
  ...
  </pre>

  the server can respond with

  <pre>
  HTTP/1.1 200 OK
  Content-Type: text/html
  ...
  <a http-header>Origin-Policy</a>: allowed=("policy-1")
  <a http-header>Vary</a>: origin-policy
  ...
  </pre>

  Upon seeing the `<a http-header><code>Origin-Policy</code></a>` header, the browser will check if it has a cached origin policy for <code>https://example.com/</code>, with "<code>policy-1</code>" as one of its [=origin policy/IDs=]. For this first request, no such cache entry is found. Since the [=null policy=] is not in the header's <code>allowed</code> list, this means that although the browser can continue to download the response body, further processing of the response (in this case [=navigate|navigation=]) is blocked on retrieving and applying the origin policy. So the browser does that:

  <pre>
  GET /.well-known/origin-policy HTTP/1.1
  Host: example.com
  Connection: keep-alive
  ...
  </pre>

  and gets back

  <pre>
  HTTP/1.1 200 OK
  Content-Type: application/originpolicy+json
  Cache-Control: max-age=86400
  ... response body as above ...
  </pre>

  The navigation to <code>https://example.com/</code> then proceeds as normal, with the [=/content security policy=] indicated in the [=origin policy manifest=] applied.
</div>

<div class="example" id="example-repeat-visit">
  From the landing page at <code>https://example.com/</code>, the user clicks a link and navigates to <code>https://example.com/about</code>. The request and response headers are the same as in the previous example, but this time the browser handles things a bit differently.

  This time, when the browser goes to look for "<code>policy-1</code>", it finds a matching policy in the HTTP cache. (We're assuming here that less than 86400 seconds have passed.) So no requests to <code>https://example.com/.well-known/origin-policy</code> need to be made, and the response for <code>https://example.com/about</code> can be immediately processed, with the origin policy applied.
</div>

<div class="example" id="example-third-party">
  GigaCorp, Inc., located at <code>https://example.net</code>, wishes to include a widget from MegaCorp on their page. They embed it using an <{iframe}>:

  <xmp highlight="html">
    <iframe src="https://example.com/widget"></iframe>
  </xmp>

  When a user visits <code>https://example.net</code>, the subresource request for <code>https://example.com/widget</code> goes through the same origin policy retrieval process as in <a href="#example-initial-policy">the first visit</a>. Note that this is true <em>even if the user has already visited <code>https://example.com</code></em>, because origin policies are stored in the HTTP cache, which is <a href="https://github.com/whatwg/fetch/pull/943">partitioned</a> by top-level origin. <!-- TODO xref top-level origin when it's defined --> That is, there is no cache entry for <code>https://example.com/.well-known/origin-policy</code> in the HTTP cache partition corresponding to <code>https://example.net</code>. See [[#tracking]] for more on why this is the case.

  But the HTTP cache still helps: repeat visits to <code>https://example.net</code> will be able to use the <code>https://example.com/.well-known/origin-policy</code> cache entry in the <code>https://example.net</code> cache partition, and avoid fetching the origin policy for the embedded <{iframe}>.
</div>

<div class="example" id="example-policy-update">
  <!-- TODO will this become document policy? -->
  MegaCorp., Inc. is interested in removing all uses of synchronous {{XMLHttpRequest}} from their site. They think they've got them all, but they'd like to roll out a report-only [=feature policy=] to be sure.

  They update their [=origin policy manifest=] to include such reporting:

  <pre highlight="json">
  {
    "<a for="origin policy manifest">ids</a>": ["policy-1"],
    "<a for="origin policy manifest">content_security</a>": {
      "<a for="origin policy manifest/content_security">policies</a>": ["<a>script-src</a> 'self' https://cdn.example.com"]
    },
  <mark>  "<a for="origin policy manifest">features</a>": {
      "policy_report_only": "<a spec="xhr">sync-xhr</a> 'none'"
    }</mark>
  }
  </pre>

  New visitors to their site, who download the origin policy manifest for the first time, will get this updated policy, and thus their browsers will report any synchronous XHRs. The same is true for visitors whose cache entry for the origin policy manifest expires, once they re-fetch the updated one. But can we do better?

  Yes, we can! The trick is to leverage the [=origin policy/IDs|policy IDs=] mechanism. First, update the manifest with a new ID:

  <pre highlight="json">
  {
  <mark>  "<a for="origin policy manifest">ids</a>": ["policy-2"]</mark>,
    "<a for="origin policy manifest">content_security</a>": {
      "<a for="origin policy manifest/content_security">policies</a>": ["<a>script-src</a> 'self' https://cdn.example.com"]
    },
    "<a for="origin policy manifest">features</a>": {
      "policy_report_only": "<a spec="xhr">sync-xhr</a> 'none'"
    }
  }
  </pre>

  Then, change the `<a http-header><code>Origin-Policy</code></a>` response header to indicate that this new policy is preferred:

  <pre>
  <a http-header>Origin-Policy</a>: allowed=("policy-1" "policy-2"), preferred="policy-2"
  </pre>

  When the browser sees this header value on any response from <code>https://example.com</code>, one of three things will happen:

  * It will have no origin policy cached for <code>https://example.com</code>. Then, the browser will fetch <code>https://example.com/.well-known/origin-policy</code> before processing the response, and get the result, which has "<code>policy-2</code>" as one of its [=origin policy/IDs=]. Thus the response will be loaded with the feature policy applied.

  * It will have the previous policy, with <code>"ids": ["policy-1"]</code>, cached. In this case, because "<code>policy-1</code>" is in the <code>allowed</code> list, it applies the previous policy to the resource being loaded, without blocking response processing on any origin policy fetches. This means the feature policy does not apply to the loaded resource. But because "<code>policy-2</code>" was marked as <code>preferred</code>, the browser will additionally fetch <code>https://example.com/.well-known/origin-policy</code> to update its cache entry, so that any future fetches for <code>https://example.com</code> can benefit from the newest revision, and have the feature policy applied.

  * It will have the new policy, with <code>"ids": ["policy-2"]</code>, cached. In this case, the <code>preferred</code> policy is available, so the browser uses that, and does not need to bother re-fetching the origin policy manifest.

  In this way, MegaCorp can deploy the new origin policy even to clients within the 24-hour <code>max-age</code> window for the origin policy resource, without incurring any extra fetches if the good-enough previous policy is available for immediate use.
</div>

<div class="example" id="example-policy-multiple-ids">
  The above example has a flaw when combined with cached resources. Consider the case where the user has previously visited <code>https://example.com/static-page.html</code>, which was delivered with headers such as

  <pre>
  HTTP/1.1 200 OK
  Content-Type: text/html
  ...
  <a http-header>Origin-Policy</a>: allowed=("policy-1")
  <a http-header>Vary</a>: origin-policy
  Cache-Control: max-age=31536000
  ...
  </pre>

  i.e. the page was cached for a year.

  If the user re-visits this URL, then the page will be loaded from the cache. But the cached page does not allow "<code>policy-2</code>", which is the only [=origin policy/ID=] found in the current origin policy at <code>https://example.com/.well-known/origin-policy</code>. It only allows "<code>policy-1</code>".

  As with all origin policy mismatches, this will cause a re-fetch of the origin policy to try to find a new policy that matches the one requested by the `<a http-header><code>Origin-Policy</code></a>` header. (We saw this previously on <a href="#example-initial-policy">the first visit</a>, when the page requested "<code>policy-1</code>" but the current policy for the origin was the [=null policy=].) But in this case, such a request will just return the same origin policy manifest, with <code>"ids": ["policy-2"]</code>. Thus, <code>https://example.com/static-page.html</code> will fail to load.

  To fix this, the server operator can instead update their origin policy as follows:

  <pre highlight="json">
  {
  <mark>  "<a for="origin policy manifest">ids</a>": ["policy-1", "policy-2"]</mark>,
    "<a for="origin policy manifest">content_security</a>": {
      "<a for="origin policy manifest/content_security">policies</a>": ["<a>script-src</a> 'self' https://cdn.example.com"]
    },
    "<a for="origin policy manifest">features</a>": {
      "policy_report_only": "<a spec="xhr">sync-xhr</a> 'none'"
    }
  }
  </pre>

  This would mean that the new origin policy is able to be applied even when "<code>policy-1</code>" is requested, such as in the case of our cached static page.

  The general rule here is that when adding a new value to the "<code><a for="origin policy manifest">ids</a></code>" field of their origin policy manifest, server operators will be best served by keeping any previous [=origin policy/IDs=] as well, at least until any cached resources that reference that origin policy could have expired.
</div>

<div class="example" id="example-killswitch">
  MegaCorp wishes to remove the origin policy, and ensure that any visitors to its site no longer get any of its effects. It can do so by using the following `<a http-header><code>Origin-Policy</code></a>` response header:

  <pre>
  <a http-header>Origin-Policy</a>: allowed=(null)
  </pre>

  When the browser recieves this header, it will ensure that no origin policy is applied for the response, since only the [=null policy=] is allowed. It will also evict any cache entries for <code>https://example.com/.well-known/origin-policy</code>.
</div>

</div>

<h2 id="framework">Framework</h2>

<h3 id="origin-policy-header">The `<code>Origin-Policy</code>` HTTP header</h3>

The `<dfn http-header><code>Origin-Policy</code></dfn>` response [=header=] can be used to indicate the allowed and preferred [=/origin policy=] used when processing a [=response=]. It may be sent on any HTTP response, in order to update the user agent's record of a given [=/origin=]'s [=/origin policy=].

`<a http-header><code>Origin-Policy</code></a>` is a [=structured header/dictionary=] structured header. The dictionary has two keys: [[!STRUCTURED-HEADERS]]

* <code>allowed</code>, whose value is an [=structured header/inner list=] that contains [=valid origin policy IDs=] as strings, or the token <code>null</code>, and
* <code>preferred</code>, whose value is a [=valid origin policy ID=].

At least one of these two entries needs to be provided for the header to have useful behavior.

No [=structured header/parameters=] are used in any locations within the structured header.

The processing model for this header, including the fallback behavior for when it is not provided or does not conform to the above data model, is given in [[#from-response]]. In general, the fallback behavior for malformed headers is to behave the same as if `<code>Origin-Policy: allowed=(null)</code>` is sent, and thus use the [=null policy|null origin policy=] for processing the [=response=]. The processing model for omitting the header is to use any previously-cached [=/origin policy=] for the [=/origin=].

<h3 id="manifest-file">The origin policy manifest</h3>

The <dfn>origin policy manifest</dfn> is a JSON-formatted document consisting of a top-level object with one or more members. Its [=MIME type=] is <dfn export><code>application/originpolicy+json</code></dfn>, and it is always treated as [=UTF-8=].

<div class="example" id="example-manifest-structure">
  <pre highlight="json">
  {
    "<a for="origin policy manifest">ids</a>": ["my-policy"],
    "<a for="origin policy manifest">features</a>": {
      "<a for="origin policy manifest/features">policy</a>": "fullscreen 'none'; geolocation 'none'"
    },
    "<a for="origin policy manifest">content_security</a>": {
      "<a for="origin policy manifest/content_security">policies</a>": ["<a>frame-ancestors</a> 'none'", "<a>object-src</a> 'none'"],
      "<a for="origin policy manifest/content_security">policies_report_only</a>": ["<a>script-src</a> 'self' https://cdn.example.com/js/"]
    }
  }
  </pre>
</div>

This section gives an overview of the file format, as well authoring requirements. The processing model for the manifest, including how to deal with violations of these authoring requirements, are handled by the algorithms in [[#parsing]].

<h4 id="manifest-ids">The "<code>ids</code>" member</h4>

The "<dfn for="origin policy manifest"><code>ids</code></dfn>" member defines the [=origin policy/IDs=] of the [=/origin policy=]. These are used, in conjunction with the `<a http-header><code>Origin-Policy</code></a>` header, to allow [=/origins=] to express their preferences and requirements among any previously-cached revisions of the [=origin policy manifest=].

It must be present, and must be an array containing only [=valid origin policy ID=] strings. At least one such string must be present in the array.

<h4 id="policy-item-features">The "<code>features</code>" policy item</h4>

The "<dfn for="origin policy manifest"><code>features</code></dfn>" member defines the baseline [=feature policy=] to apply to any responses from the origin.

If present, it must be an object, with one possible key: "<dfn for="origin policy manifest/features"><code>policy</code></dfn>". The "<code>policy</code>" sub-member's value must be a string that matches the <a spec="FEATURE-POLICY"><code>serialized-feature-policy</code></a> production. [[!FEATURE-POLICY]]

<p class="note">Although the `<a http-header><code>Feature-Policy</code></a>` header tolerates using commas as a separator, that is an artifact of the HTTP header serialization, and commas will cause parsing failures inside an [=origin policy manifest=].</p>

As per the processing model in [[#monkeypatch-fp]], feature policy directives supplied here serve as a baseline, which the `<a http-header><code>Feature-Policy</code></a>` header on individual responses can override on an individual feature basis.

<div class="example" id="example-feature-policy">
  If a [=response=] is processed with the [=origin policy manifest=] given by

  <pre highlight="json">
  {
    "<a for="origin policy manifest">ids</a>": ["my-policy"],
    "<a for="origin policy manifest">features</a>": {
      "<a for="origin policy manifest/features">policy</a>": "fullscreen 'self'; geolocation 'none'"
    }
  }
  </pre>

  and the `<a http-header><code>Feature-Policy</code></a>` header

  <pre>
    <a http-header>Feature-Policy</a>: fullscreen https://example.com; camera 'self'
  </pre>

  then the resulting {{Document}}'s <a for="Document" spec="HTML">feature policy</a> will be «[ "fullscreen" → «https://example.com/», "geolocation" → «'none'», "camera" → «'self'» ]». Note how the allowlists are overwritten; they do not combine.
</div>

<h4 id="policy-item-content_security">The "<code>content_security</code>" policy item</h4>

The "<dfn for="origin policy manifest"><code>content_security</code></dfn>" member defines zero or more [=/content security policies=] to apply to any responses from the origin.

If present, it must be an object, with two possible keys: "<dfn for="origin policy manifest/content_security"><code>policies</code></dfn>" and "<dfn for="origin policy manifest/content_security"><code>policies_report_only</code></dfn>". Both sub-members' values must be arrays containing zero or more strings, where the strings match the [=serialized CSP=] production. [[!CSP]]

<p class="note">Although the `<a http-header><code>Content-Security-Policy</code></a>` and `<a http-header><code>Content-Security-Policy-Report-Only</code></a>` headers tolerate using commas as a separator, that is an artifact of the HTTP header serialization, and commas will cause parsing failures inside an [=origin policy manifest=]. Instead, [=CSP lists=] are represented as arrays, so if you wish to use multiple [=/content security policies=], include them as multiple array members.</p>

As per the processing model in [[#monkeypatch-csp]], content security policies supplied here are applied before any from the `<a http-header><code>Content-Security-Policy</code></a>`/`<a http-header><code>Content-Security-Policy-Report-Only</code></a>` headers on individual responses. When used together, they combine  the usual manner for multi-item [=CSP lists=].

<div class="example" id="example-csp">
  If a [=response=] is processed with the [=origin policy manifest=] given by

  <pre highlight="json">
  {
    "<a for="origin policy manifest">ids</a>": ["my-policy"],
    "<a for="origin policy manifest">content_security</a>": {
      "<a for="origin policy manifest/content_security">policies</a>": ["<a>script-src</a> cdn.example.org 'unsafe-inline'; <a>object-src</a> 'none'"]
    }
  }
  </pre>

  and the `<a http-header><code>Content-Security-Policy</code></a>` header

  <pre>
    <a http-header>Content-Security-Policy</a>: <a>script-src</a> 'nonce-random123' 'strict-dynamic' 'unsafe-inline' https:
  </pre>

  then the resulting {{Document}}'s [=Document/CSP list=] will contain two separate [=content security policy object|content security policies=], with the combined effect of only allowing scripts which match both policies. In this case, it will accept scripts with a nonce of <code>random123</code> (per the header policy) which are either inline <{script}> blocks or come from <code>cdn.example.org</code> (per the origin policy).
</div>

<h3 id="origin-policy-well-known">The <code>origin-policy</code> well-known URL</h3>

[=Origin policy manifests=] for a given [=/origin=] are located at the well-known URL <code>/.well-known/origin-policy</code>. [[!RFC8615]]

Servers who wish to provide an origin policy will need to respond to `<code>GET</code>` [=requests=] to this URL with the contents of their [=origin policy manifest=], including setting the correct value of <a><code>application/originpolicy+json</code></a> for the response's `<code>Content-Type</code>` header.

The usual caching strategies (e.g. long <code>max-age</code>, or using the `<code>Etag</code>` header) are quite useful in conjunction with the <code>/.well-known/origin-policy</code> resource, especially since the `<a http-header><code>Origin-Policy</code></a>` header can be used to force a cache refresh.

The processing model for how browsers send [=requests=] to this URL is given in [[#updating]].

<h2 id="data-model">Data model</h2>

An <dfn>origin policy</dfn> is a [=struct=] containing the following [=struct/items=]:

: <dfn for="origin policy">IDs</dfn>
:: Either a [=list=] of [=/strings=] which are each a [=valid origin policy ID=], or a list containing the single item null.
: <dfn for="origin policy">feature policy</dfn>
:: A [=feature policy directive=]. [[!FEATURE-POLICY]]
: <dfn for="origin policy">content security policies</dfn>
:: A [=list=] of [=content security policy object|content security policies=]. [[!CSP]]

The <dfn>null policy</dfn> is an [=/origin policy=] whose [=origin policy/IDs=] is a list containing the single item null, and who has empty lists for its [=origin policy/feature policy=] and [=origin policy/content security policies=]. As enforced by the processing model, no other policy can have a null in its [=origin policy/IDs=] list.

A [=/string=] is a <dfn>valid origin policy ID</dfn> if all of the following are true:

* It is not the empty string
* It only contains [=code points=] in the range U+0020 SPACE through U+007E (~), inclusive. (This is the same as the range specified to be parseable as a string via structured headers. [[STRUCTURED-HEADERS]])

<h2 id="processing-model">Processing model</h2>

<h3 id="from-response">Response processing</h3>

This section details the entry point algorithms, for determining which origin policy applies to an incoming [=response=].

<div algorithm>
  To <dfn>update the origin policy from a response</dfn>, given a [=response=] |response| and an [=environment settings object=] |client|:

  1. If |response|'s [=response/URL=] is null, then return "<code>success</code>".
  1. Let |header| be the result of [=header list/getting=] `<a http-header><code>Origin-Policy</code></a>` from |response|'s [=response/header list=].
  1. If |header| is null, then return "<code>success</code>".
  1. Let (|allowedIds|, |preferredId|) be the result of <a>parsing an `<code>Origin-Policy</code>` header</a> given |header|. If this instead returns "<code>unparseable</code>", then return "<code>success</code>".
  1. Let |origin| be |response|'s [=response/URL=]'s [=url/origin=].
  1. Return the result of [=updating an origin's origin policy=] for |origin| given |client| and |allowedIds|. If |preferredId| is not null, pass it along too.
</div>

<div algorithm>
  To <dfn data-lt="parse an `Origin-Policy` header|parsing an `Origin-Policy` header">parse an `<code>Origin-Policy</code>` header</dfn> given a [=byte sequence=] |headerBytes|:

  1. Let |parsedHeader| be the result of [=parsing a structured header=] given |headerBytes| and "<code>dictionary</code>". If this fails, then return "<code>unparseable</code>".
  1. Let |allowedIds| be an empty [=ordered set=].
  1. If |parsedHeader|["<code>allowed</code>"] [=map/exists=]:
    1. If |parsedHeader|["<code>allowed</code>"][0] is not a [=list=], then return "<code>unparseable</code>".
    1. Let |rawAllowedList| be |parsedHeader|["<code>allowed</code>"][0].
    1. [=For each=] |itemTuple| in |rawAllowedList|:
      1. Let |allowedId| be |itemTuple|[0].
      1. If |allowedId| is not a [=structured header/string=] or the [=structured header/token=] <code>null</code>, then return "<code>unparseable</code>".
      1. Assert: if |allowedId| is a string, then it is a [=valid origin policy ID=].
      1. If |allowedId| is the <code>null</code> [=structured header/token=], then set |allowedId| to null. <span class="note">This is just a "type conversion" into our usual value space of Infra values. [[!INFRA]]</span>
      1. [=set/Append=] |allowedId| to |allowedIds|.
  1. Let |preferredId| be null.
  1. If |parsedHeader|["<code>preferred</code>"] [=map/exists=]:
    1. Set |preferredId| to |parsedHeader|["<code>preferred</code>"][0].
    1. If |preferredId| is not a [=structured header/string=], or is the empty string, then return "<code>unparseable</code>".
    1. Assert: |preferredId| is a [=valid origin policy ID=].
  1. Return the [=tuple=] (|allowedIds|, |preferredId|).

  <p class="note">The constant lookups of the 0th [=tuple/item=] in [=tuples=] above is due to the way that structured header parse results are generally packaged as tuples where the 0th item is the value of interest, and the 1st item is an associated [=ordered map=] of [=structured header/parameters=]. In all cases we ignore the parameters.</p>
</div>

<h3 id="updating">Updating the origin policy</h3>

<div algorithm>
  To <dfn lt="update an origin's origin policy|updating an origin's origin policy">update an origin's origin policy</dfn> for an [=/origin=] |origin| given an [=environment settings object=] |client|, a [=list=] of strings |allowedIds| and an optional string |preferredId|:

  1. Let |cachedPolicy| be the result of [=retrieving the cached origin policy=] for |origin|.
  1. If |preferredId| was given, and is [=list/contained=] in |cachedPolicy|'s [=origin policy/IDs=], then return "<code>success</code>".
     <p class="note">Since |preferredId| is always a [=valid origin policy ID=], and in particular is not null, this step will never match if |cachedPolicy| is the [=null policy=].</p>
  1. Let |url| be the result of [=getting the origin policy manifest URL=] for |origin|.
  1. If |url| is null, then return "<code>success</code>".
  1. Let |networkRequest| be a new [=request=] whose [=request/url=] is |url|, [=request/client=] is |client|, [=request/service-workers mode=] is "<code>none</code>", [=request/destination=] is "<code>manifest</code>", [=request/mode=] is "<code>same-origin</code>", [=request/redirect mode=] is "<code>error</code>", [=request/credentials mode=] is "<code>omit</code>", [=request/referrer policy=] is "<code>no-referrer</code>", and [=request/cache mode=] is "<code>no-cache</code>".
  1. If any of |allowedIds| are [=list/contained=] in |cachedPolicy|'s [=origin policy/IDs=], then:
    1. If |cachedPolicy| is the [=null policy=], or |preferredId| was provided, then [=in parallel=], [=fetch=] |networkRequest|. (This will update the cache, but the [=response=] will not be used.)
    1. Return "<code>success</code>".
  1. If |allowedIds| contains null, then:
    1. If |preferredId| was provided, then [=in parallel=], [=fetch=] |networkRequest|. (This will update the cache, but the [=response=] will not be used.)
    1. Return "<code>success</code>".
  1. Let |networkResponse| be the result of [=fetching=] |networkRequest|. (Unlike the [=in parallel=] fetches, this is blocking.)
  1. Let |networkPolicy| be the result of [=getting an origin policy from a manifest response=] given |networkResponse|.
  1. If either of the following is true:
      * |preferredId| was given, and is [=list/contained=] in |networkPolicy|'s [=origin policy/IDs=]; or
      * |allowedIds| [=list/contains=] one of |networkPolicy|'s [=origin policy/IDs=],
    then return "<code>success</code>".
  1. Return "<code>failure</code>".

  <p class="note">Although this specification uses the full [=fetching=] mechanism to check the HTTP cache for an origin policy, and then [=getting an origin policy from a manifest response|re-parses=] the result each time, implementations could use a more efficient mechanism, as long as the results are observably equivalent. In such cases, implementations ought to take particular care around respecting the cache expiration and keying semantics.</p>

  <div class="note">
    The following provides a non-normative summary of the outcomes of the above algorithm under various conditions:

    * |preferredId| matches |cachedPolicy|: use |cachedPolicy|.
    * |preferredId| mismatches |cachedPolicy| or is not provided:
      * |cachedPolicy| is the [=null policy=]:
        * |allowedIds| contains null: use the [=null policy=], and refresh the HTTP cache in the background.
        * |allowedIds| does not contain null: fetch |networkPolicy|, and use it if it matches |allowedIds| or |preferredId|.
      * |cachedPolicy| is not the [=null policy=]:
        * |allowedIds| contains one of |cachedPolicy|'s [=origin policy/IDs=]: use |cachedPolicy|, and refresh the HTTP cache in the background if |preferredId| was provided.
        * |allowedIds| does not contain any of |cachedPolicy|'s [=origin policy/IDs=] but does contain null: use the [=null policy=], and refresh the HTTP cache in the background if |preferredId| was provided.
        * |allowedIds| contains neither any of |cachedPolicy|'s [=origin policy/IDs=] nor null: fetch |networkPolicy|, and use it if it matches |allowedIds| or |preferredId|.
  </div>
</div>

<!-- TODO: should this behave more like stale-while-revalidate, in particular the prevent no-cache cache-control header modification flag?-->

<div algorithm="retrieve the cached origin policy">
  To <dfn lt="retrieve the cached origin policy|retrieving the cached origin policy">retrieve the cached origin policy</dfn> for an [=/origin=] |origin|:

  1. Let |url| be the result of [=getting the origin policy manifest URL=] for |origin|.
  1. If |url| is null, return the [=null policy=].
  1. Let |cacheCheckRequest| be a new [=request=] whose [=request/url=] is |url|, [=request/client=] is null, [=request/service-workers mode=] is "<code>none</code>", [=request/destination=] is "<code>manifest</code>", [=request/mode=] is "<code>same-origin</code>", [=request/redirect mode=] is "<code>error</code>", [=request/credentials mode=] is "<code>omit</code>", and [=request/cache mode=] is "<code>only-if-cached</code>".
  1. Let |cachedResponse| be the result of [=fetching=] |cacheCheckRequest|.
  1. Return the result of [=getting an origin policy from a manifest response=] given |cachedResponse|.

  We define the <dfn for="origin" export>origin policy</dfn> for a given [=/origin=] to be the result of [=retrieving the cached origin policy=] for that origin.
</div>

<div algorithm>
  To <dfn lt="get the origin policy manifest URL|getting the origin policy manifest URL">get the origin policy manifest URL</dfn> for an [=/origin=] |origin|:

  1. If |origin| is not [=potentially trustworthy origin|potentially trusthworthy=], then return null.
  1. Return the result of [=URL parser|parsing=] the concatenation of the [=serialization of an origin|serialization=] of |origin| and "<code>/.well-known/origin-policy</code>".
</div>

<div algorithm>
  To <dfn lt="get an origin policy from a manifest response|getting an origin policy from a manifest response">get an origin policy from a response</dfn> given a [=response=] |response|:

  1. If |response|'s [=response/status=] is not an [=ok status=], then return the [=null policy=].
  1. Let |mimeType| be the result of [=extracting a MIME type=] from |response|'s [=response/header list=].
  1. If |mimeType|'s [=MIME type/essence=] is not "<code>application/originpolicy+json</code>", then return the [=null policy=].
  1. [=Wait=] for |response|'s [=response/body=].
  1. Let |string| be the result of [=UTF-8 decoding=] |response|'s [=response/body=] (treating it as a [=byte sequence=]).
  1. Return the result of [=parsing a string into an origin policy=] given |string|.
</div>

<h3 id="parsing">Parsing</h3>

This section details the parsing and validation algorithms for the JSON structure of the origin policy, i.e. turning [=strings=] into [=/origin policy=] [=structs=].

<div algorithm>
  To <dfn lt="parse a string into an origin policy|parsing a string into an origin policy">parse a string into an origin policy</dfn> given a [=string=] |string|:

  1. Let |parsed| be the result of [=parse JSON into Infra values|parsing JSON into Infra values=] given |string|. If this throws an exception, then return the [=null policy=].
  1. If |parsed| is not a [=map=], then return the [=null policy=].
  1. Let |ids| be an empty list.
  1. If |parsed|["<a for="origin policy manifest"><code>ids</code></a>"] does [=map/exists=] and is a [=list=], then [=list/for each=] |potentialId| in |parsed|["<a for="origin policy manifest"><code>ids</code></a>"]:
    1. If |potentialId| is a [=valid origin policy ID=], then [=list/append=] |potentialId| to |ids|.
  1. If |ids| [=list/is empty=], then return the [=null policy=].
  1. Let |featurePolicy| be an empty [=feature policy directive=].
  1. If |parsed|["<a for="origin policy manifest"><code>features</code></a>"] exists and is a [=map=], and |parsed|["<a for="origin policy manifest"><code>features</code></a>"]["<a for="origin policy manifest/features"><code>policy</code></a>"] exists and is a string, then set |featurePolicy| to the result of [=parsing a feature policy directive=] given |parsed|["<a for="origin policy manifest"><code>features</code></a>"]["<a for="origin policy manifest/features"><code>policy</code></a>"].
  1. Let |contentSecurityPolicies| be an empty [=list=].
  1. If |parsed|["<a for="origin policy manifest"><code>content_security</code></a>"] exists and is a [=map=], then:
    1. If |parsed|["<a for="origin policy manifest"><code>content_security</code></a>"]["<a for="origin policy manifest/content_security"><code>policies</code></a>"] exists and is a [=list=], then [=list/for each=] |potentialPolicyString| in |parsed|["<a for="origin policy manifest"><code>content_security</code></a>"]["<a for="origin policy manifest/content_security"><code>policies</code></a>"]:
      1. If |potentialPolicyString| is not a [=string=], then [=continue=].
      1. Let |policy| be the result of [$parse a serialized CSP|parsing a serialized CSP$] given |potentialPolicyString|, "<code>header</code>", and "<code>enforce</code>".
      1. If |policy|'s [=policy/directive set=] is not empty, then [=list/append=] |policy| to |contentSecurityPolicies|.
    1. If |parsed|["<a for="origin policy manifest"><code>content_security</code></a>"]["<a for="origin policy manifest/content_security"><code>policies_report_only</code></a>"] exists and is a [=list=], then [=list/for each=] |potentialPolicyString| in |parsed|["<a for="origin policy manifest"><code>content_security</code></a>"]["<a for="origin policy manifest/content_security"><code>policies_report_only</code></a>"]:
      1. If |potentialPolicyString| is not a [=string=], then [=continue=].
      1. Let |policy| be the result of [$parse a serialized CSP|parsing a serialized CSP$] given |potentialPolicyString|, "<code>header</code>", and "<code>report</code>".
      1. If |policy|'s [=policy/directive set=] is not empty, then [=list/append=] |policy| to |contentSecurityPolicies|.
  1. Return a new [=/origin policy=] whose [=origin policy/IDs=] is |ids|, [=origin policy/feature policy=] is |featurePolicy|, and [=origin policy/content security policies=] is |contentSecurityPolicies|.
</div>

<h2 id="monkeypatches">Patches to other specifications</h2>

The following patches to other specifications would be incorporated as appropriate once this specification graduates from incubation.

<h3 id="monkeypatch-fetch">Fetch</h3>

The <a spec="FETCH">HTTP-network fetch</a> algorithm is modified by inserting a step after step 5, i.e. after request body streaming has begun but before response body streaming begins. This must call [=update the origin policy from a response=] given the response and the request's [=request/client=]. (This could cause the algorithm to block while it fetches an origin policy, if required do to so by the `<a http-header><code>Origin-Policy</code></a>` header.)

<h3 id="monkeypatch-fp">Feature Policy</h3>

The [=create a feature policy for a browsing context=] algorithm is modified by modifying the returned [=feature policy=]'s <a spec="FEATURE-POLICY">declared policy</a> to be a [=map/clone=] of <var ignore>origin</var>'s [=origin/origin policy=]'s [=origin policy/feature policy=].

<p class="note">This means any allowlists provided in the `<a http-header><code>Feature-Policy</code></a>` header will override those provided by the origin policy.</p>

<h3 id="monkeypatch-csp">Content Security Policy</h3>

The two main substantive steps of the [=set response's CSP list=] algorithm are modified from

<blockquote>
  2.  Let |policies| be the result of <a spec="CSP" abstract-op lt="parse a serialized CSP list">parsing</a> the result of [=extracting header list values=] given `<a http-header><code>Content-Security-Policy</code></a>` and |response|'s [=response/header list=], with a [=policy/source=] of "<code>header</code>", and a [=policy/disposition=] of "<code>enforce</code>".

  3. [=list/Append=] to |policies| the result of <a spec="CSP" abstract-op lt="parse a serialized CSP list">parsing</a> the result of [=extracting header list values=] given `<a http-header><code>Content-Security-Policy-Report-Only</code></a>` and |response|'s [=response/header list=], with a [=policy/source=] of "<code>header</code>", and a [=policy/disposition=] of "<code>report</code>".
</blockquote>

to

<blockquote>
  2. Let |policies| be a [=list/clone=] of |response|'s [=response/URL=]'s [=url/origin=]'s [=origin/origin policy=]'s [=origin policy/content security policies=].

  3. [=list/Append=] to |policies| the result of <a spec="CSP" abstract-op lt="parse a serialized CSP list">parsing</a> the result of [=extracting header list values=] given `<a http-header><code>Content-Security-Policy</code></a>` and |response|'s [=response/header list=], with a [=policy/source=] of "<code>header</code>", and a [=policy/disposition=] of "<code>enforce</code>".

  4. [=list/Append=] to |policies| the result of <a spec="CSP" abstract-op lt="parse a serialized CSP list">parsing</a> the result of [=extracting header list values=] given `<a http-header><code>Content-Security-Policy-Report-Only</code></a>` and |response|'s [=response/header list=], with a [=policy/source=] of "<code>header</code>", and a [=policy/disposition=] of "<code>report</code>".
</blockquote>

<h2 id="privacy-and-security">Privacy and security considerations</h2>

<h3 id="tracking">Tracking</h3>

The use of HTTP responses and the HTTP cache as the source of truth for origin policies, as outlined in [[#updating]], brings with it the usual privacy considerations related to the HTTP cache. In particular, to avoid using an origin policy as a tracking vector, user agents need to implement the full HTTP cache semantics for origin policies, including recent innovations such as <a href="https://github.com/whatwg/fetch/issues/904">double-keying</a>. Similarly, user agents need to ensure that when the user clears their HTTP cache entries for an origin, any cached origin policies are similarly cleared.

We mention these concerns here because although the processing model uses the HTTP cache directly, we anticipate that implementations might use a separate storage mechanism for origin policies behind the scenes, e.g. for performance reasons. That is, these concerns are taken care of automatically at the specification level, but might require extra care while implementing.

<h3 id="well-known-security">The use of a well-known URL</h3>

This specification forces the [=origin policy manifest=] to live at a specific URL, <code>/.well-known/origin-policy</code>. Compared to using a configurable location, this choice enhances security.

In particular, the action of setting a policy for an entire origin is an action that should involve the folks responsible for running the origin's server, as it has cross-cutting effects upon every application hosted on an origin. That is, the use of a well-known URL ensures that individual web application developers, without access to the entire server and its configuration, cannot interfere with other web applications running on that same origin.

Consider, for example, MegaCorp, Inc.'s <code>https://example.com</code>, which hosts a mail application, a mapping application, a document editing application, and so on. It would be unfortunate indeed if one of these applications accidentally pinned a policy to the entire origin which didn't account for the rest of the origin's contents. To mitigate that risk, this specification forces the manifest to live in a shared location for all of <code>https://example.com</code>. The goal is explicitly to elicit the kind of discussion and compromise within an origin that needs to happen in order to deploy an origin policy safely.

<h2 id="iana">IANA Considerations</h2>

<h3 id="iana-header">The `<code>Origin-Policy</code>` header</h3>

This section provides the provisional registration of the [=header=] `<a http-header><code>Origin-Policy</code></a>` in accordance with <cite>Registration Procedures for Message Header Fields</cite>. [[!RFC3864]]

: Header field name
:: <code>Origin-Policy</code>
: Applicable protocol
:: http
: Status
:: standard
: Author/Change controller
:: WICG
: Specification document(s)
:: <a href="https://wicg.github.io/origin-policy/">https://wicg.github.io/origin-policy/</a> (see [[#origin-policy-header]])

<h3 id="iana-mime-type">The <code>application/originpolicy+json</code> MIME type</h3>

This section provides the provisional registration of the [=MIME type=] <a><code>application/originpolicy+json</code></a> in accordance with <cite>Media Type Specifications and Registration Procedures</cite>. [[!RFC6838]]

: Type name
:: <code>application</code>
: Subtype name
:: <code>originpolicy+json</code>
: Required parameters
:: N/A
: Optional parameters
:: N/A
: Encoding considerations
:: 8bit (always UTF-8)
: Security considerations
:: See [[#privacy-and-security]]
: Interoperability considerations
:: TODO
: Published specification
:: <a href="https://wicg.github.io/origin-policy/">https://wicg.github.io/origin-policy/</a> (see [[#manifest-file]])
: Applications that use this media type
:: Web browsers
: Fragment identifier considerations
:: N/A
: Additional information
  <dd>
    <dl>
      : Deprecated alias names for this type
      :: N/A
      : Magic number(s)
      :: N/A
      : File extension(s)
      :: None. Often these files will be named <code>origin-policy</code> (with no extension) on typical server setups.
      : Macintosh file type code
      :: Same as for <code>application/json</code> [[!RFC8259]]
    </dl>
  </dd>
: Person & email address to contact for further information
:: Domenic Denicola <a href="mailto:d@domenic.me">d@domenic.me</a>
: Intended usage
:: Common
: Restrictions on usage
:: No restrictions apply.
: Change controller
:: WICG

<h3 id="iana-well-known">Well-known <code>origin-policy</code> URI</h3>

This section provides the provisional registration of the <code>origin-policy</code> well-known URI in the Well-Known URIs registry in accordance with <cite>Well-Known Uniform Resource Identifiers (URIs)</cite>. [[!RFC8615]]

<p class="note">Although the rest of this specification, and indeed the rest of the web platform, <a href="https://url.spec.whatwg.org/#url-apis-elsewhere">uses the term "URL"</a>, this section in particular intersects with a community that uses the term "URI".</p>

: URI suffix
:: <code>origin-policy</code>
: Change controller
:: WICG
: Specification document(s)
:: <a href="https://wicg.github.io/origin-policy/">https://wicg.github.io/origin-policy/</a> (see [[#origin-policy-well-known]])
: Related information
:: N/A

<h2 id="ack">Acknowledgments</h2>

Thanks to Mark Nottingham for his <cite>Site-Wide HTTP Headers</cite> draft, which provided inspiration. Likewise, Takeshi Yoshino's <cite>Origin-Wide CORS</cite> proposal attempts to address some of the same problems as origin policy. [[SITE-WIDE-HEADERS]] [[ORIGIN-WIDE-CORS]]

Thanks to
Anne van Kesteren,
Daniel Hausknecht,
Daniel Vogelheim,
Jeffrey Yasskin, and
Nihanth Subramanya
for being awesome!
